'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shared = require('../shared-7c700083.js');
var index = require('../index-4491caf0.js');
require('@edgestore/shared');
require('@panva/hkdf');
require('cookie');
require('jose');
require('uuid');

// type guard for `content`
function isTextContent(content) {
    return typeof content === 'string';
}
function isBlobContent(content) {
    return typeof content !== 'string' && 'blob' in content;
}
function initEdgeStoreClient(config) {
    const sdk = index.initEdgeStoreSdk({
        accessKey: config.accessKey,
        secretKey: config.secretKey
    });
    return new Proxy({}, {
        get (_target, key) {
            const bucketName = key;
            const bucket = config.router.buckets[bucketName];
            if (!bucket) {
                throw new Error(`Bucket ${bucketName} not found`);
            }
            const client = {
                async upload (params) {
                    const content = params.content;
                    const ctx = 'ctx' in params ? params.ctx : {};
                    const input = 'input' in params ? params.input : {};
                    const { blob, extension } = await (async ()=>{
                        if (isTextContent(content)) {
                            return {
                                blob: new Blob([
                                    content
                                ], {
                                    type: 'text/plain'
                                }),
                                extension: 'txt'
                            };
                        } else if (isBlobContent(content)) {
                            return {
                                blob: content.blob,
                                extension: content.extension
                            };
                        } else {
                            return {
                                blob: await getBlobFromUrl(content.url),
                                extension: content.extension
                            };
                        }
                    })();
                    const path = shared.buildPath({
                        bucket,
                        pathAttrs: {
                            ctx,
                            input
                        },
                        fileInfo: {
                            type: blob.type,
                            size: blob.size,
                            extension,
                            temporary: false,
                            fileName: params.options?.manualFileName,
                            replaceTargetUrl: params.options?.replaceTargetUrl
                        }
                    });
                    const metadata = await bucket._def.metadata({
                        ctx,
                        input
                    });
                    const requestUploadRes = await sdk.requestUpload({
                        bucketName,
                        bucketType: bucket._def.type,
                        fileInfo: {
                            fileName: params.options?.manualFileName,
                            replaceTargetUrl: params.options?.replaceTargetUrl,
                            type: blob.type,
                            size: blob.size,
                            extension,
                            isPublic: bucket._def.accessControl === undefined,
                            temporary: params.options?.temporary ?? false,
                            path,
                            metadata
                        }
                    });
                    const { signedUrl, multipart } = requestUploadRes;
                    if (multipart) {
                        // TODO
                        throw new Error('Multipart upload not implemented');
                    } else if (signedUrl) {
                        await fetch(signedUrl, {
                            method: 'PUT',
                            body: blob
                        });
                    } else {
                        throw new Error('Missing signedUrl');
                    }
                    const { parsedPath, pathOrder } = shared.parsePath(path);
                    return {
                        url: requestUploadRes.accessUrl,
                        size: blob.size,
                        metadata,
                        path: parsedPath,
                        pathOrder
                    };
                },
                async getFile (params) {
                    const res = await sdk.getFile(params);
                    return {
                        url: getUrl(res.url, config.baseUrl),
                        size: res.size,
                        uploadedAt: new Date(res.uploadedAt),
                        metadata: res.metadata,
                        path: res.path
                    };
                },
                async confirmUpload (params) {
                    return await sdk.confirmUpload(params);
                },
                async deleteFile (params) {
                    return await sdk.deleteFile(params);
                },
                async listFiles (params) {
                    const res = await sdk.listFiles({
                        bucketName,
                        ...params
                    });
                    const files = res.data.map((file)=>{
                        return {
                            url: getUrl(file.url, config.baseUrl),
                            thumbnailUrl: file.thumbnailUrl,
                            size: file.size,
                            uploadedAt: new Date(file.uploadedAt),
                            metadata: file.metadata,
                            path: file.path
                        };
                    });
                    return {
                        data: files,
                        pagination: res.pagination
                    };
                }
            };
            return client;
        }
    });
}
/**
 * Protected files need third-party cookies to work.
 * Since third party cookies doesn't work on localhost,
 * we need to proxy the file through the server.
 */ function getUrl(url, baseUrl) {
    if (process.env.NODE_ENV === 'development' && !url.includes('/_public/')) {
        if (!baseUrl) {
            throw new Error('Missing baseUrl. You need to pass the baseUrl to `initEdgeStoreClient` to get protected files in development.');
        }
        const proxyUrl = new URL(baseUrl);
        proxyUrl.pathname = `${proxyUrl.pathname}/proxy-file`;
        proxyUrl.search = new URLSearchParams({
            url
        }).toString();
        return proxyUrl.toString();
    }
    return url;
}
async function getBlobFromUrl(url) {
    const res = await fetch(url);
    return await res.blob();
}

exports.edgeStoreRawSdk = index.edgeStoreRawSdk;
exports.initEdgeStoreSdk = index.initEdgeStoreSdk;
exports.initEdgeStoreClient = initEdgeStoreClient;
