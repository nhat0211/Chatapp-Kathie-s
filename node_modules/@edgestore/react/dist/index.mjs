import * as React from 'react';
import { EdgeStoreApiClientError } from '@edgestore/shared';

class EdgeStoreClientError extends Error {
    constructor(message){
        super(message);
        this.name = 'EdgeStoreError';
    }
}

async function handleError(res) {
    let json = {};
    try {
        json = await res.json();
    } catch (err) {
        throw new EdgeStoreClientError(`Failed to parse response. Make sure the api is correctly configured at ${res.url}`);
    }
    throw new EdgeStoreApiClientError({
        response: json
    });
}

function createNextProxy({ apiPath, uploadingCountRef, maxConcurrentUploads = 5 }) {
    return new Proxy({}, {
        get (_, prop) {
            const bucketName = prop;
            const bucketFunctions = {
                upload: async (params)=>{
                    try {
                        params.onProgressChange?.(0);
                        while(uploadingCountRef.current >= maxConcurrentUploads && uploadingCountRef.current > 0){
                            await new Promise((resolve)=>setTimeout(resolve, 300));
                        }
                        uploadingCountRef.current++;
                        const test = await uploadFile(params, {
                            bucketName: bucketName,
                            apiPath
                        });
                        return test;
                    } finally{
                        uploadingCountRef.current--;
                    }
                },
                confirmUpload: async (params)=>{
                    const { success } = await confirmUpload(params, {
                        bucketName: bucketName,
                        apiPath
                    });
                    if (!success) {
                        throw new EdgeStoreClientError('Failed to confirm upload');
                    }
                },
                delete: async (params)=>{
                    const { success } = await deleteFile(params, {
                        bucketName: bucketName,
                        apiPath
                    });
                    if (!success) {
                        throw new EdgeStoreClientError('Failed to delete file');
                    }
                }
            };
            return bucketFunctions;
        }
    });
}
async function uploadFile({ file, input, onProgressChange, options }, { apiPath, bucketName }) {
    try {
        onProgressChange?.(0);
        const res = await fetch(`${apiPath}/request-upload`, {
            method: 'POST',
            credentials: 'include',
            body: JSON.stringify({
                bucketName,
                input,
                fileInfo: {
                    extension: file.name.split('.').pop(),
                    type: file.type,
                    size: file.size,
                    fileName: options?.manualFileName,
                    replaceTargetUrl: options?.replaceTargetUrl,
                    temporary: options?.temporary
                }
            }),
            headers: {
                'Content-Type': 'application/json'
            }
        });
        if (!res.ok) {
            await handleError(res);
        }
        const json = await res.json();
        if ('multipart' in json) {
            await multipartUpload({
                bucketName,
                multipartInfo: json.multipart,
                onProgressChange,
                file,
                apiPath
            });
        } else if ('uploadUrl' in json) {
            // Single part upload
            // Upload the file to the signed URL and get the progress
            await uploadFileInner(file, json.uploadUrl, onProgressChange);
        } else {
            throw new EdgeStoreClientError('An error occurred');
        }
        return {
            url: getUrl(json.accessUrl, apiPath),
            thumbnailUrl: json.thumbnailUrl ? getUrl(json.thumbnailUrl, apiPath) : null,
            size: json.size,
            uploadedAt: new Date(json.uploadedAt),
            path: json.path,
            pathOrder: json.pathOrder,
            metadata: json.metadata
        };
    } catch (e) {
        onProgressChange?.(0);
        throw e;
    }
}
/**
 * Protected files need third-party cookies to work.
 * Since third party cookies doesn't work on localhost,
 * we need to proxy the file through the server.
 */ function getUrl(url, apiPath) {
    const mode = typeof process !== 'undefined' ? process.env.NODE_ENV : import.meta.env?.DEV ? 'development' : 'production';
    if (mode === 'development' && !url.includes('/_public/')) {
        const proxyUrl = new URL(window.location.origin);
        proxyUrl.pathname = `${apiPath}/proxy-file`;
        proxyUrl.search = new URLSearchParams({
            url
        }).toString();
        return proxyUrl.toString();
    }
    return url;
}
const uploadFileInner = async (file, uploadUrl, onProgressChange)=>{
    const promise = new Promise((resolve, reject)=>{
        const request = new XMLHttpRequest();
        request.open('PUT', uploadUrl);
        // This is for Azure provider. Specifies the blob type
        request.setRequestHeader('x-ms-blob-type', 'BlockBlob');
        request.addEventListener('loadstart', ()=>{
            onProgressChange?.(0);
        });
        request.upload.addEventListener('progress', (e)=>{
            if (e.lengthComputable) {
                // 2 decimal progress
                const progress = Math.round(e.loaded / e.total * 10000) / 100;
                onProgressChange?.(progress);
            }
        });
        request.addEventListener('error', ()=>{
            reject(new Error('Error uploading file'));
        });
        request.addEventListener('abort', ()=>{
            reject(new Error('File upload aborted'));
        });
        request.addEventListener('loadend', ()=>{
            // Return the ETag header (needed to complete multipart upload)
            resolve(request.getResponseHeader('ETag'));
        });
        request.send(file);
    });
    return promise;
};
async function multipartUpload(params) {
    const { bucketName, multipartInfo, onProgressChange, file, apiPath } = params;
    const { partSize, parts, totalParts, uploadId, key } = multipartInfo;
    const uploadingParts = [];
    const uploadPart = async (params)=>{
        const { part, chunk } = params;
        const { uploadUrl } = part;
        const eTag = await uploadFileInner(chunk, uploadUrl, (progress)=>{
            const uploadingPart = uploadingParts.find((p)=>p.partNumber === part.partNumber);
            if (uploadingPart) {
                uploadingPart.progress = progress;
            } else {
                uploadingParts.push({
                    partNumber: part.partNumber,
                    progress
                });
            }
            const totalProgress = Math.round(uploadingParts.reduce((acc, p)=>acc + p.progress * 100, 0) / totalParts) / 100;
            onProgressChange?.(totalProgress);
        });
        if (!eTag) {
            throw new EdgeStoreClientError('Could not get ETag from multipart response');
        }
        return {
            partNumber: part.partNumber,
            eTag
        };
    };
    // Upload the parts in parallel
    const completedParts = await queuedPromises({
        items: parts.map((part)=>({
                part,
                chunk: file.slice((part.partNumber - 1) * partSize, part.partNumber * partSize)
            })),
        fn: uploadPart,
        maxParallel: 5,
        maxRetries: 10
    });
    // Complete multipart upload
    const res = await fetch(`${apiPath}/complete-multipart-upload`, {
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
            bucketName,
            uploadId,
            key,
            parts: completedParts
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    if (!res.ok) {
        await handleError(res);
    }
}
async function confirmUpload({ url }, { apiPath, bucketName }) {
    const res = await fetch(`${apiPath}/confirm-upload`, {
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
            url,
            bucketName
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    if (!res.ok) {
        await handleError(res);
    }
    return res.json();
}
async function deleteFile({ url }, { apiPath, bucketName }) {
    const res = await fetch(`${apiPath}/delete-file`, {
        method: 'POST',
        credentials: 'include',
        body: JSON.stringify({
            url,
            bucketName
        }),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    if (!res.ok) {
        await handleError(res);
    }
    return res.json();
}
async function queuedPromises({ items, fn, maxParallel, maxRetries = 0 }) {
    const results = new Array(items.length);
    const executeWithRetry = async (func, retries)=>{
        try {
            return await func();
        } catch (error) {
            if (retries > 0) {
                await new Promise((resolve)=>setTimeout(resolve, 5000));
                return executeWithRetry(func, retries - 1);
            } else {
                throw error;
            }
        }
    };
    const semaphore = {
        count: maxParallel,
        async wait () {
            // If we've reached our maximum concurrency or it's the last item, wait
            while(this.count <= 0)await new Promise((resolve)=>setTimeout(resolve, 500));
            this.count--;
        },
        signal () {
            this.count++;
        }
    };
    const tasks = items.map((item, i)=>(async ()=>{
            await semaphore.wait();
            try {
                const result = await executeWithRetry(()=>fn(item), maxRetries);
                results[i] = result;
            } finally{
                semaphore.signal();
            }
        })());
    await Promise.all(tasks);
    return results;
}

const DEFAULT_BASE_URL = (typeof process !== 'undefined' ? process.env.NEXT_PUBLIC_EDGE_STORE_BASE_URL : import.meta.env?.EDGE_STORE_BASE_URL) ?? 'https://files.edgestore.dev';
function createEdgeStoreProvider(opts) {
    const EdgeStoreContext = /*#__PURE__*/ React.createContext(undefined);
    const EdgeStoreProvider = ({ children, basePath })=>{
        return EdgeStoreProviderInner({
            children,
            context: EdgeStoreContext,
            basePath,
            maxConcurrentUploads: opts?.maxConcurrentUploads
        });
    };
    function useEdgeStore() {
        if (!EdgeStoreContext) {
            throw new Error('React Context is unavailable in Server Components');
        }
        // @ts-expect-error - We know that the context value should not be undefined
        const value = React.useContext(EdgeStoreContext);
        if (!value && process.env.NODE_ENV !== 'production') {
            throw new Error('[edgestore]: `useEdgeStore` must be wrapped in a <EdgeStoreProvider />');
        }
        return value;
    }
    return {
        EdgeStoreProvider,
        useEdgeStore
    };
}
function EdgeStoreProviderInner({ children, context, basePath, maxConcurrentUploads }) {
    const apiPath = basePath ? `${basePath}` : '/api/edgestore';
    const [state, setState] = React.useState({
        loading: true,
        initialized: false,
        error: false
    });
    const uploadingCountRef = React.useRef(0);
    const initExecuted = React.useRef(false); // to make sure we don't run init twice
    React.useEffect(()=>{
        if (!initExecuted.current) {
            void init();
        }
        return ()=>{
            initExecuted.current = true;
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    async function init() {
        try {
            setState({
                loading: true,
                initialized: false,
                error: false
            });
            const res = await fetch(`${apiPath}/init`, {
                method: 'POST',
                credentials: 'include'
            });
            if (res.ok) {
                const json = await res.json();
                const innerRes = await fetch(`${DEFAULT_BASE_URL}/_init`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'x-edgestore-token': json.token
                    }
                });
                if (innerRes.ok) {
                    // update state
                    setState({
                        loading: false,
                        initialized: true,
                        error: false
                    });
                } else {
                    setState({
                        loading: false,
                        initialized: false,
                        error: true
                    });
                    throw new EdgeStoreClientError("Couldn't initialize Edge Store.");
                }
            } else {
                setState({
                    loading: false,
                    initialized: false,
                    error: true
                });
                await handleError(res);
            }
        } catch (err) {
            setState({
                loading: false,
                initialized: false,
                error: true
            });
            throw err;
        }
    }
    async function reset() {
        await init();
    }
    return /*#__PURE__*/ React.createElement(React.Fragment, null, /*#__PURE__*/ React.createElement(context.Provider, {
        value: {
            edgestore: createNextProxy({
                apiPath,
                uploadingCountRef,
                maxConcurrentUploads
            }),
            reset,
            state
        }
    }, children));
}

export { createEdgeStoreProvider };
