'use strict';

var shared = require('@edgestore/shared');

const DEFAULT_MESSAGE = `Missing EDGE_STORE_ACCESS_KEY or EDGE_STORE_SECRET_KEY. 
This can happen if you are trying to import something related to the backend of Edge Store in a client component.`;
class EdgeStoreCredentialsError extends Error {
    constructor(message = DEFAULT_MESSAGE){
        super(message);
        this.name = 'EdgeStoreCredentialsError';
    }
}

const API_ENDPOINT = process.env.EDGE_STORE_API_ENDPOINT ?? 'https://api.edgestore.dev';
async function makeRequest(params) {
    const { body, accessKey, secretKey, path } = params;
    const res = await fetch(`${API_ENDPOINT}${path}`, {
        method: 'POST',
        body: JSON.stringify(body),
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Basic ${Buffer.from(`${accessKey}:${secretKey}`).toString('base64')}`
        }
    });
    if (!res.ok) {
        throw new Error(`Failed to make request to ${path}: ${await res.text()}`);
    }
    return await res.json();
}
const edgeStoreRawSdk = {
    async getToken (params) {
        const reqBuckets = Object.entries(params.router.buckets).reduce((acc, [bucketName, bucket])=>{
            acc[bucketName] = {
                path: bucket._def.path.map((p)=>{
                    const paramEntries = Object.entries(p);
                    if (paramEntries[0] === undefined) {
                        throw new shared.EdgeStoreError({
                            message: `Empty path param found in: ${JSON.stringify(bucket._def.path)}`,
                            code: 'SERVER_ERROR'
                        });
                    }
                    const [key, value] = paramEntries[0];
                    return {
                        key,
                        value: value()
                    };
                }),
                accessControl: bucket._def.accessControl
            };
            return acc;
        }, {});
        const { token } = await makeRequest({
            body: {
                ctx: params.ctx,
                buckets: reqBuckets
            },
            accessKey: params.accessKey,
            secretKey: params.secretKey,
            path: '/get-token'
        });
        return token;
    },
    async getFile ({ accessKey, secretKey, url }) {
        return await makeRequest({
            path: '/get-file',
            accessKey,
            secretKey,
            body: {
                url
            }
        });
    },
    async requestUpload ({ accessKey, secretKey, bucketName, bucketType, fileInfo, multipart }) {
        const res = await makeRequest({
            path: '/request-upload',
            accessKey,
            secretKey,
            body: {
                multipart,
                bucketName,
                bucketType,
                isPublic: fileInfo.isPublic,
                path: fileInfo.path,
                extension: fileInfo.extension,
                size: fileInfo.size,
                mimeType: fileInfo.type,
                metadata: fileInfo.metadata,
                fileName: fileInfo.fileName,
                replaceTargetUrl: fileInfo.replaceTargetUrl,
                isTemporary: fileInfo.temporary
            }
        });
        return {
            multipart: res.multipart,
            signedUrl: res.signedUrl,
            accessUrl: res.url,
            path: res.path,
            thumbnailUrl: res.thumbnailUrl
        };
    },
    async requestUploadParts ({ accessKey, secretKey, key, multipart }) {
        const res = await makeRequest({
            path: '/request-upload-parts',
            accessKey,
            secretKey,
            body: {
                multipart,
                key
            }
        });
        return {
            multipart: res.multipart
        };
    },
    async completeMultipartUpload ({ accessKey, secretKey, uploadId, key, parts }) {
        return await makeRequest({
            path: '/complete-multipart-upload',
            accessKey,
            secretKey,
            body: {
                uploadId,
                key,
                parts
            }
        });
    },
    async confirmUpload ({ accessKey, secretKey, url }) {
        return await makeRequest({
            path: '/confirm-upload',
            accessKey,
            secretKey,
            body: {
                url
            }
        });
    },
    async deleteFile ({ accessKey, secretKey, url }) {
        return await makeRequest({
            path: '/delete-file',
            accessKey,
            secretKey,
            body: {
                url
            }
        });
    },
    async listFiles ({ accessKey, secretKey, bucketName, filter, pagination }) {
        return await makeRequest({
            path: '/list-files',
            accessKey,
            secretKey,
            body: {
                bucketName,
                filter,
                pagination
            }
        });
    }
};
function initEdgeStoreSdk(params) {
    const { accessKey = process.env.EDGE_STORE_ACCESS_KEY, secretKey = process.env.EDGE_STORE_SECRET_KEY } = params ?? {};
    if (!accessKey || !secretKey) {
        throw new EdgeStoreCredentialsError();
    }
    return {
        async getToken (params) {
            return await edgeStoreRawSdk.getToken({
                accessKey,
                secretKey,
                ctx: params.ctx,
                router: params.router
            });
        },
        async getFile ({ url }) {
            return await edgeStoreRawSdk.getFile({
                accessKey,
                secretKey,
                url
            });
        },
        async requestUpload ({ bucketName, bucketType, fileInfo, multipart }) {
            return await edgeStoreRawSdk.requestUpload({
                accessKey,
                secretKey,
                bucketName,
                bucketType,
                fileInfo,
                multipart
            });
        },
        async requestUploadParts ({ key, multipart }) {
            return await edgeStoreRawSdk.requestUploadParts({
                accessKey,
                secretKey,
                key,
                multipart
            });
        },
        async completeMultipartUpload ({ uploadId, key, parts }) {
            return await edgeStoreRawSdk.completeMultipartUpload({
                accessKey,
                secretKey,
                uploadId,
                key,
                parts
            });
        },
        async confirmUpload ({ url }) {
            return await edgeStoreRawSdk.confirmUpload({
                accessKey,
                secretKey,
                url
            });
        },
        async deleteFile ({ url }) {
            return await edgeStoreRawSdk.deleteFile({
                accessKey,
                secretKey,
                url
            });
        },
        async listFiles (params) {
            return await edgeStoreRawSdk.listFiles({
                accessKey,
                secretKey,
                ...params
            });
        }
    };
}

exports.EdgeStoreCredentialsError = EdgeStoreCredentialsError;
exports.edgeStoreRawSdk = edgeStoreRawSdk;
exports.initEdgeStoreSdk = initEdgeStoreSdk;
