"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  constructCloudinaryUrl: () => constructCloudinaryUrl,
  effects: () => effects,
  position: () => position,
  primary: () => primary,
  text: () => text,
  transformationPlugins: () => transformationPlugins
});
module.exports = __toCommonJS(src_exports);

// src/lib/cloudinary.ts
var import_zod25 = require("zod");
var import_url_gen = require("@cloudinary/url-gen");
var import_util5 = require("@cloudinary-util/util");

// src/plugins/abr.ts
var abr_exports = {};
__export(abr_exports, {
  assetTypes: () => assetTypes,
  plugin: () => plugin,
  props: () => props
});
var import_zod = require("zod");
var props = {
  streamingProfile: import_zod.z.string().describe(JSON.stringify({
    text: "The streaming profile to apply when delivering a video using adaptive bitrate streaming.",
    url: "https://cloudinary.com/documentation/transformation_reference#sp_streaming_profile"
  })).optional()
};
var assetTypes = ["video", "videos"];
function plugin(props20) {
  const { cldAsset, options } = props20;
  const { streamingProfile } = options;
  if (typeof streamingProfile === "string") {
    cldAsset.addTransformation(`sp_${streamingProfile}`);
  }
  return {};
}

// src/plugins/cropping.ts
var cropping_exports = {};
__export(cropping_exports, {
  assetTypes: () => assetTypes2,
  normalizeNumberParameter: () => normalizeNumberParameter,
  plugin: () => plugin2,
  props: () => props2
});

// src/constants/parameters.ts
var parameters_exports = {};
__export(parameters_exports, {
  angle: () => angle,
  aspectRatio: () => aspectRatio,
  aspectRatioModesEnum: () => aspectRatioModesEnum,
  crop: () => crop,
  cropModesEnum: () => cropModesEnum,
  flags: () => flags,
  flagsEnum: () => flagsEnum,
  gravity: () => gravity,
  height: () => height,
  width: () => width,
  widthResize: () => widthResize,
  x: () => x,
  y: () => y,
  zoom: () => zoom
});
var import_zod2 = require("zod");
var angle = {
  qualifier: "a",
  schema: import_zod2.z.union([
    import_zod2.z.string(),
    import_zod2.z.number()
  ]).describe(JSON.stringify({
    text: "Rotates or flips an asset by the specified number of degrees or automatically according to its orientation or available metadata.",
    url: "https://cloudinary.com/documentation/transformation_reference#a_angle"
  }))
};
var aspectRatioModesEnum = import_zod2.z.enum([
  "vflip",
  "hflip",
  "ignore",
  "auto_right",
  "auto_left"
]);
var aspectRatio = {
  qualifier: "ar",
  schema: import_zod2.z.union([
    import_zod2.z.number(),
    aspectRatioModesEnum,
    import_zod2.z.string()
  ]).describe(JSON.stringify({
    text: "Crops or resizes the asset to a new aspect ratio.",
    url: "https://cloudinary.com/documentation/transformation_reference#ar_aspect_ratio"
  }))
};
var cropModesEnum = import_zod2.z.enum([
  "fill",
  "lfill",
  "fill_pad",
  "crop",
  "thumb",
  "scale",
  "fit",
  "limit",
  "mfit",
  "pad",
  "lpad",
  "mpad",
  "imagga_scale",
  "imagga_crop"
]);
var crop = {
  qualifier: "c",
  schema: cropModesEnum.describe(JSON.stringify({
    text: "Mode to use when cropping an asset.",
    url: "https://cloudinary.com/documentation/transformation_reference#c_crop_resize"
  }))
};
var flagsEnum = import_zod2.z.enum([
  "animated",
  "any_format",
  "apng",
  "attachment",
  "awebp",
  "clip",
  "clip_evenodd",
  "cutter",
  "force_icc",
  "force_strip",
  "getinfo",
  "group4",
  "hlsv3",
  "ignore_aspect_ratio",
  "ignore_mask_channels",
  "immutable_cache",
  "keep_attribution",
  "keep_dar",
  "keep_iptc",
  "layer_apply",
  "lossy",
  "mono",
  "no_overflow",
  "no_stream",
  "png8_fl_png24_fl_png32",
  "preserve_transparency",
  "progressive",
  "rasterize",
  "region_relative",
  "relative",
  "replace_image",
  "sanitize",
  "splice",
  "streaming_attachment",
  "strip_profile",
  "text_disallow_overflow",
  "text_no_trim",
  "tiff8_lzw",
  "tiled",
  "truncate_ts",
  "waveform"
]);
var flags = {
  qualifier: "fl",
  schema: import_zod2.z.union([
    flagsEnum,
    import_zod2.z.array(flagsEnum)
  ]).describe(JSON.stringify({
    text: "Alters the regular behavior of another transformation or the overall delivery behavior.",
    url: "https://cloudinary.com/documentation/transformation_reference#fl_flag"
  }))
};
var gravity = {
  qualifier: "g",
  schema: import_zod2.z.string().describe(JSON.stringify({
    text: "Determines which part of an asset to focus on. Note: Default of auto is applied for supported crop modes only.",
    url: "https://cloudinary.com/documentation/transformation_reference#g_gravity"
  }))
};
var height = {
  qualifier: "h",
  schema: import_zod2.z.union([
    import_zod2.z.number(),
    import_zod2.z.string()
  ]).describe(JSON.stringify({
    text: "A qualifier that determines the height of a transformed asset or an overlay.",
    url: "https://cloudinary.com/documentation/transformation_reference#h_height"
  }))
};
var width = {
  qualifier: "w",
  schema: import_zod2.z.union([
    import_zod2.z.number(),
    import_zod2.z.string()
  ]).describe(JSON.stringify({
    text: "A qualifier that sets the desired width of an asset using a specified value, or automatically based on the available width.",
    url: "https://cloudinary.com/documentation/transformation_reference#w_width"
  }))
};
var widthResize = {
  schema: import_zod2.z.union([
    import_zod2.z.string(),
    import_zod2.z.number()
  ]).describe(JSON.stringify({
    text: "Width to resize the asset after all transformations are applied. Useful for responsive resizing."
  }))
};
var x = {
  qualifier: "x",
  schema: import_zod2.z.union([
    import_zod2.z.string(),
    import_zod2.z.number()
  ]).describe(JSON.stringify({
    text: "Adjusts the starting location or offset of the x axis.",
    url: "https://cloudinary.com/documentation/transformation_reference#x_y_coordinates"
  }))
};
var y = {
  qualifier: "y",
  schema: import_zod2.z.union([
    import_zod2.z.string(),
    import_zod2.z.number()
  ]).describe(JSON.stringify({
    text: "Adjusts the starting location or offset of the y axis.",
    url: "https://cloudinary.com/documentation/transformation_reference#x_y_coordinates"
  }))
};
var zoom = {
  schema: import_zod2.z.string().describe(JSON.stringify({
    text: "Controls how close to crop to the detected coordinates when using face-detection, custom-coordinate, or object-specific gravity.",
    url: "https://cloudinary.com/documentation/transformation_reference#z_zoom"
  }))
};

// src/plugins/cropping.ts
var cropsAspectRatio = ["crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsGravityAuto = ["crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsWithZoom = ["crop", "thumb"];
var DEFAULT_CROP = "limit";
var props2 = {
  aspectRatio: aspectRatio.schema.optional(),
  crop: crop.schema.default(DEFAULT_CROP).optional(),
  gravity: gravity.schema.optional(),
  widthResize: widthResize.schema.optional(),
  zoom: zoom.schema.optional()
};
var assetTypes2 = ["image", "images", "video", "videos"];
function normalizeNumberParameter(param) {
  if (typeof param !== "string")
    return param;
  return parseInt(param);
}
function plugin2(props20) {
  const { cldAsset, options } = props20;
  const {
    aspectRatio: aspectRatio2,
    width: defaultWidth,
    height: defaultHeight,
    widthResize: defaultWidthResize,
    // Default the crop to "limit" to avoid upscaling, even when widthResize is passed in.
    // This avoid further distorting the image since the browser will resize in that case.
    // If caller wants actual resize, can explicitly pass in "scale".
    crop: crop2 = DEFAULT_CROP
  } = options;
  const overrides = {
    width: void 0
  };
  let height2 = normalizeNumberParameter(defaultHeight);
  let width2 = normalizeNumberParameter(defaultWidth);
  let widthResize2 = normalizeNumberParameter(defaultWidthResize);
  const hasDefinedDimensions = height2 || width2;
  const hasValidAspectRatio = aspectRatio2 && cropsAspectRatio.includes(crop2);
  let transformationString = "";
  if (crop2 && (hasDefinedDimensions || hasValidAspectRatio)) {
    transformationString = `c_${crop2}`;
  }
  if (hasValidAspectRatio) {
    transformationString = `${transformationString},ar_${aspectRatio2}`;
  }
  if (width2) {
    transformationString = `${transformationString},w_${width2}`;
  }
  if (!options.gravity && cropsGravityAuto.includes(crop2)) {
    options.gravity = "auto";
  }
  if (!["limit"].includes(crop2) && typeof height2 === "number") {
    transformationString = `${transformationString},h_${height2}`;
  }
  if (options.gravity) {
    if (options.gravity === "auto" && !cropsGravityAuto.includes(crop2)) {
      console.warn(`Auto gravity can only be used with crop modes: ${cropsGravityAuto.join(", ")}. Not applying gravity.`);
    } else {
      transformationString = `${transformationString},g_${options.gravity}`;
    }
  }
  if (options.zoom) {
    if (options.zoom === "auto" && !cropsWithZoom.includes(crop2)) {
      console.warn(`Zoom can only be used with crop modes: ${cropsWithZoom.join(", ")}. Not applying zoom.`);
    } else {
      transformationString = `${transformationString},z_${options.zoom}`;
    }
  }
  cldAsset.effect(transformationString);
  if (widthResize2) {
    overrides.width = widthResize2;
  }
  return {
    options: overrides
  };
}

// src/plugins/default-image.ts
var default_image_exports = {};
__export(default_image_exports, {
  assetTypes: () => assetTypes3,
  plugin: () => plugin3,
  props: () => props3
});
var import_zod3 = require("zod");
var import_util = require("@cloudinary-util/util");
var props3 = {
  defaultImage: import_zod3.z.string().describe(JSON.stringify({
    text: "Configures the default image to use in case the given public ID is not available. Must include file extension.",
    url: "https://cloudinary.com/documentation/transformation_reference#d_default_image"
  })).optional()
};
var assetTypes3 = ["image", "images"];
function plugin3(props20) {
  const { cldAsset, options } = props20;
  const { defaultImage } = options;
  if (typeof defaultImage === "string") {
    if (!(0, import_util.getFormat)(defaultImage)) {
      console.warn(`The defaultImage prop may be missing a format and must include it along with the public ID. (Ex: myimage.jpg)`);
    }
    const defaultImageId = defaultImage.replace(/\//g, ":");
    cldAsset.addTransformation(`d_${defaultImageId}`);
  }
  return {};
}

// src/plugins/effects.ts
var effects_exports = {};
__export(effects_exports, {
  assetTypes: () => assetTypes4,
  plugin: () => plugin4,
  props: () => props4
});
var import_zod5 = require("zod");

// src/constants/qualifiers.ts
var import_zod4 = require("zod");
var import_util2 = require("@cloudinary-util/util");
var convertersColors = [
  {
    test: import_util2.testColorIsHex,
    convert: import_util2.convertColorHexToRgb
  }
];
var primary = {
  aspectRatio,
  crop,
  gravity,
  height,
  width
};
var position = {
  angle,
  gravity,
  x,
  y
};
var text = {
  alignment: {
    qualifier: false,
    order: 6
  },
  antialias: {
    qualifier: "antialias"
  },
  border: {
    qualifier: "bo",
    location: "primary"
  },
  color: {
    qualifier: "co",
    location: "primary",
    converters: convertersColors
  },
  fontFamily: {
    qualifier: false,
    order: 1
  },
  fontSize: {
    qualifier: false,
    order: 2
  },
  fontStyle: {
    qualifier: false,
    order: 4
  },
  fontWeight: {
    qualifier: false,
    order: 3
  },
  hinting: {
    qualifier: "hinting"
  },
  letterSpacing: {
    qualifier: "letter_spacing"
  },
  lineSpacing: {
    qualifier: "line_spacing"
  },
  stroke: {
    qualifier: "self",
    order: 7
  },
  textDecoration: {
    qualifier: false,
    order: 5
  }
};
var effects = {
  art: {
    prefix: "e",
    qualifier: "art",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Applies the selected artistic filter.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_art"
    }))
  },
  autoBrightness: {
    prefix: "e",
    qualifier: "auto_brightness",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image brightness and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_brightness"
    }))
  },
  autoColor: {
    prefix: "e",
    qualifier: "auto_color",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image color balance and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_color"
    }))
  },
  autoContrast: {
    prefix: "e",
    qualifier: "auto_contrast",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image contrast and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_contrast"
    }))
  },
  assistColorblind: {
    prefix: "e",
    qualifier: "assist_colorblind",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies stripes or color adjustment to help people with common color blind conditions to differentiate between colors that are similar for them.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_assist_colorblind"
    }))
  },
  background: {
    qualifier: "b",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Applies a background to empty or transparent areas.",
      url: "https://cloudinary.com/documentation/transformation_reference#b_background"
    }))
  },
  blackwhite: {
    prefix: "e",
    qualifier: "blackwhite",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Converts an image to black and white.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blackwhite"
    }))
  },
  blur: {
    prefix: "e",
    qualifier: "blur",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a blurring filter to an asset.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur"
    }))
  },
  blurFaces: {
    prefix: "e",
    qualifier: "blur_faces",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Blurs all detected faces in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur_faces"
    }))
  },
  blurRegion: {
    prefix: "e",
    qualifier: "blur_region",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a blurring filter to the region of an image specified by x, y, width and height, or an area of text. If no region is specified, the whole image is blurred.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur_region"
    }))
  },
  border: {
    qualifier: "bo",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Adds a solid border around an image or video.",
      url: "https://cloudinary.com/documentation/transformation_reference#bo_border"
    }))
  },
  brightness: {
    prefix: "e",
    qualifier: "brightness",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the image or video brightness.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_brightness"
    }))
  },
  brightnessHSB: {
    prefix: "e",
    qualifier: "brightness_hsb",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts image brightness modulation in HSB to prevent artifacts in some images.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_brightness_hsb"
    }))
  },
  cartoonify: {
    prefix: "e",
    qualifier: "cartoonify",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a cartoon effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_cartoonify"
    }))
  },
  color: {
    qualifier: "co",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "A qualifier that specifies the color to use with the corresponding transformation.",
      url: "https://cloudinary.com/documentation/transformation_reference#co_color"
    })),
    converters: convertersColors
  },
  colorize: {
    prefix: "e",
    qualifier: "colorize",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Colorizes an image. By default, gray is used for colorization. You can specify a different color using the color qualifier.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_colorize"
    }))
  },
  contrast: {
    prefix: "e",
    qualifier: "contrast",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image or video contrast.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_contrast"
    }))
  },
  displace: {
    prefix: "e",
    qualifier: "distort",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Displaces the pixels in an image according to the color channels of the pixels in another specified image (a gradient map specified with the overlay parameter).",
      url: "https://cloudinary.com/documentation/transformation_reference#e_displace"
    }))
  },
  distort: {
    prefix: "e",
    qualifier: "distort",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Distorts an image to a new shape by either adjusting its corners or by warping it into an arc.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_distort"
    }))
  },
  fillLight: {
    prefix: "e",
    qualifier: "fill_light",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the fill light and optionally blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_fill_light"
    }))
  },
  gamma: {
    prefix: "e",
    qualifier: "gamma",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the image or video gamma level.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_gamma"
    }))
  },
  gradientFade: {
    prefix: "e",
    qualifier: "gradient_fade",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a gradient fade effect from the edge of an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_gradient_fade"
    }))
  },
  grayscale: {
    prefix: "e",
    qualifier: "grayscale",
    schema: import_zod4.z.boolean().describe(JSON.stringify({
      text: "Converts an image to grayscale (multiple shades of gray).",
      url: "https://cloudinary.com/documentation/transformation_reference#e_grayscale"
    }))
  },
  hue: {
    prefix: "e",
    qualifier: "hue",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image's hue.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_hue"
    }))
  },
  improve: {
    prefix: "e",
    qualifier: "improve",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image's colors, contrast and brightness to improve its appearance.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_improve"
    }))
  },
  multiply: {
    prefix: "e",
    qualifier: "multiply",
    schema: import_zod4.z.boolean().describe(JSON.stringify({
      text: "A qualifier that blends image layers using the multiply blend mode",
      url: "https://cloudinary.com/documentation/transformation_reference#e_multiply"
    }))
  },
  negate: {
    prefix: "e",
    qualifier: "negate",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_negate",
      url: "https://cloudinary.com/documentation/transformation_reference#e_negate"
    }))
  },
  noise: {
    prefix: "e",
    qualifier: "noise",
    schema: import_zod4.z.boolean().describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_noise",
      url: "https://cloudinary.com/documentation/transformation_reference#e_noise"
    }))
  },
  oilPaint: {
    prefix: "e",
    qualifier: "oil_paint",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_oil_paint",
      url: "https://cloudinary.com/documentation/transformation_reference#e_oil_paint"
    }))
  },
  opacity: {
    qualifier: "o",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.number()
    ]).describe(JSON.stringify({
      text: "Adjusts the opacity of an asset and makes it semi-transparent.",
      url: "https://cloudinary.com/documentation/transformation_reference#o_opacity"
    }))
  },
  outline: {
    prefix: "e",
    qualifier: "outline",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adds an outline effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_outline"
    }))
  },
  pixelate: {
    prefix: "e",
    qualifier: "pixelate",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a pixelation effect.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate"
    }))
  },
  pixelateFaces: {
    prefix: "e",
    qualifier: "pixelate_faces",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Pixelates all detected faces in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate_faces"
    }))
  },
  pixelateRegion: {
    prefix: "e",
    qualifier: "pixelate_region",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Pixelates the region of an image specified by x, y, width and height, or an area of text.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate_region"
    }))
  },
  radius: {
    qualifier: "r",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Rounds the corners of an image or video.",
      url: "https://cloudinary.com/documentation/transformation_reference#r_round_corners"
    }))
  },
  redeye: {
    prefix: "e",
    qualifier: "redeye",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically removes red eyes in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_redeye"
    }))
  },
  replaceColor: {
    prefix: "e",
    qualifier: "replace_color",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Maps an input color and those similar to the input color to corresponding shades of a specified output color.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_replace_color"
    }))
  },
  saturation: {
    prefix: "e",
    qualifier: "saturation",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image or video saturation level.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_saturation"
    }))
  },
  screen: {
    prefix: "e",
    qualifier: "screen",
    schema: import_zod4.z.boolean().describe(JSON.stringify({
      text: "A qualifier that blends image layers using the screen blend mode.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_screen"
    }))
  },
  sepia: {
    prefix: "e",
    qualifier: "sepia",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Changes the color scheme of an image to sepia.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_sepia"
    }))
  },
  shadow: {
    prefix: "e",
    qualifier: "shadow",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Adds a gray shadow to the bottom right of an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_shadow"
    }))
  },
  sharpen: {
    prefix: "e",
    qualifier: "sharpen",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a sharpening filter.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_sharpen"
    }))
  },
  shear: {
    prefix: "e",
    qualifier: "shear",
    schema: import_zod4.z.string().describe(JSON.stringify({
      text: "Skews an image according to the two specified values in degrees.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_shear"
    }))
  },
  simulateColorblind: {
    prefix: "e",
    qualifier: "simulate_colorblind",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Simulates the way an image would appear to someone with the specified color blind condition.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_simulate_colorblind"
    }))
  },
  tint: {
    prefix: "e",
    qualifier: "tint",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Blends an image with one or more tint colors at a specified intensity.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_tint"
    }))
  },
  trim: {
    prefix: "e",
    qualifier: "trim",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Detects and removes image edges whose color is similar to the corner pixels.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_trim"
    }))
  },
  unsharpMask: {
    prefix: "e",
    qualifier: "unsharp_mask",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies an unsharp mask filter to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_unsharp_mask"
    }))
  },
  vectorize: {
    prefix: "e",
    qualifier: "vectorize",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Vectorizes an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vectorize"
    }))
  },
  vibrance: {
    prefix: "e",
    qualifier: "vibrance",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a vibrance filter to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vibrance"
    }))
  },
  vignette: {
    prefix: "e",
    qualifier: "vignette",
    schema: import_zod4.z.union([
      import_zod4.z.string(),
      import_zod4.z.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a vignette effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vignette"
    }))
  }
};

// src/lib/transformations.ts
function constructTransformation({ prefix, qualifier, value, converters }) {
  let transformation = "";
  if (prefix) {
    transformation = `${prefix}_`;
  }
  let transformationValue = value;
  converters?.forEach(({ test, convert }) => {
    if (!test(transformationValue))
      return;
    transformationValue = convert(transformationValue);
  });
  if (transformationValue === true || transformationValue === "true") {
    return `${transformation}${qualifier}`;
  }
  if (typeof transformationValue === "string" || typeof transformationValue === "number") {
    if (prefix) {
      return `${transformation}${qualifier}:${transformationValue}`;
    } else {
      return `${qualifier}_${transformationValue}`;
    }
  }
}
function promptArrayToString(promptArray) {
  return `(${promptArray.join(";")})`;
}

// src/plugins/effects.ts
var effectProps = {
  art: effects.art.schema.optional(),
  autoBrightness: effects.autoBrightness.schema.optional(),
  autoColor: effects.autoColor.schema.optional(),
  autoContrast: effects.autoContrast.schema.optional(),
  assistColorblind: effects.assistColorblind.schema.optional(),
  background: effects.background.schema.optional(),
  blackwhite: effects.blackwhite.schema.optional(),
  blur: effects.blur.schema.optional(),
  blurFaces: effects.blurFaces.schema.optional(),
  blurRegion: effects.blurRegion.schema.optional(),
  border: effects.border.schema.optional(),
  brightness: effects.brightness.schema.optional(),
  brightnessHSB: effects.brightnessHSB.schema.optional(),
  cartoonify: effects.cartoonify.schema.optional(),
  color: effects.color.schema.optional(),
  colorize: effects.colorize.schema.optional(),
  contrast: effects.contrast.schema.optional(),
  distort: effects.distort.schema.optional(),
  fillLight: effects.fillLight.schema.optional(),
  gamma: effects.gamma.schema.optional(),
  gradientFade: effects.gradientFade.schema.optional(),
  grayscale: effects.grayscale.schema.optional(),
  improve: effects.improve.schema.optional(),
  multiply: effects.multiply.schema.optional(),
  negate: effects.negate.schema.optional(),
  oilPaint: effects.oilPaint.schema.optional(),
  opacity: effects.opacity.schema.optional(),
  outline: effects.outline.schema.optional(),
  pixelate: effects.pixelate.schema.optional(),
  pixelateFaces: effects.pixelateFaces.schema.optional(),
  pixelateRegion: effects.pixelateRegion.schema.optional(),
  radius: effects.radius.schema.optional(),
  redeye: effects.redeye.schema.optional(),
  replaceColor: effects.replaceColor.schema.optional(),
  saturation: effects.saturation.schema.optional(),
  screen: effects.screen.schema.optional(),
  sepia: effects.sepia.schema.optional(),
  shadow: effects.shadow.schema.optional(),
  sharpen: effects.sharpen.schema.optional(),
  shear: effects.shear.schema.optional(),
  simulateColorblind: effects.simulateColorblind.schema.optional(),
  tint: effects.tint.schema.optional(),
  trim: effects.trim.schema.optional(),
  unsharpMask: effects.unsharpMask.schema.optional(),
  vectorize: effects.vectorize.schema.optional(),
  vibrance: effects.vibrance.schema.optional(),
  vignette: effects.vignette.schema.optional()
};
var props4 = {
  effects: import_zod5.z.array(import_zod5.z.object(effectProps)).describe(JSON.stringify({
    text: "Array of objects specifying transformations to be applied to asset."
  })).optional(),
  ...effectProps
};
var assetTypes4 = ["image", "images", "video", "videos"];
function plugin4(props20) {
  const { cldAsset, options } = props20;
  const transformationStrings = constructTransformationString({
    effects,
    options
  });
  transformationStrings.filter((t) => !!t).forEach((transformation) => cldAsset.effect(transformation));
  ;
  if (Array.isArray(options?.effects)) {
    options?.effects.forEach((effectsSet) => {
      const transformationString = constructTransformationString({
        effects,
        options: effectsSet
      }).filter((t) => !!t).join(",");
      cldAsset.effect(transformationString);
    });
  }
  function constructTransformationString({ effects: effects2, options: options2 }) {
    return Object.keys(effects2).map((key) => {
      const { prefix, qualifier, converters } = effects2[key];
      return constructTransformation({
        qualifier,
        prefix,
        value: options2?.[key],
        converters
      });
    });
  }
  return {};
}

// src/plugins/flags.ts
var flags_exports = {};
__export(flags_exports, {
  assetTypes: () => assetTypes5,
  plugin: () => plugin5,
  props: () => props5
});
var { flagsEnum: flagsEnum2 } = parameters_exports;
var props5 = {
  flags: flags.schema.optional()
};
var assetTypes5 = ["image", "images", "video", "videos"];
function plugin5(props20) {
  const { cldAsset, options } = props20;
  const { flags: flags2 = [] } = options;
  if (Array.isArray(flags2) && flags2.length > 0) {
    flags2.forEach((flag) => {
      const { success } = flagsEnum2.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      cldAsset.addFlag(flag);
    });
  } else if (typeof flags2 === "object") {
    Object.entries(flags2).forEach(([qualifier, value]) => {
      const { success } = flagsEnum2.safeParse(qualifier);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${qualifier}, not applying.`);
        }
        return;
      }
      cldAsset.addTransformation(`fl_${qualifier}:${value}`);
    });
  }
  return {};
}

// src/plugins/fill-background.ts
var fill_background_exports = {};
__export(fill_background_exports, {
  assetTypes: () => assetTypes6,
  plugin: () => plugin6,
  props: () => props6
});
var import_zod6 = require("zod");
var props6 = {
  fillBackground: import_zod6.z.union([
    import_zod6.z.boolean(),
    import_zod6.z.object({
      crop: crop.schema.optional(),
      gravity: gravity.schema.optional(),
      prompt: import_zod6.z.string().optional()
    })
  ]).describe(JSON.stringify({
    text: "Uses Generative Fill to extended padded image with AI",
    url: "https://cloudinary.com/documentation/transformation_reference#b_gen_fill"
  })).optional()
};
var assetTypes6 = ["image", "images"];
var defaultCrop = "pad";
function plugin6(props20) {
  const { cldAsset, options } = props20;
  const { fillBackground } = options;
  if (fillBackground === true) {
    const properties = [
      "b_gen_fill",
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${defaultCrop}`
    ];
    cldAsset.addTransformation(properties.join(","));
  } else if (typeof fillBackground === "object") {
    const { crop: crop2 = defaultCrop, gravity: gravity2, prompt } = fillBackground;
    const properties = [
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${crop2}`
    ];
    if (typeof prompt === "string") {
      properties.unshift(`b_gen_fill:${prompt}`);
    } else {
      properties.unshift(`b_gen_fill`);
    }
    if (typeof gravity2 === "string") {
      properties.push(`g_${gravity2}`);
    }
    cldAsset.addTransformation(properties.join(","));
  }
  return {};
}

// src/plugins/replace.ts
var replace_exports = {};
__export(replace_exports, {
  assetTypes: () => assetTypes7,
  plugin: () => plugin7,
  props: () => props7
});
var import_zod7 = require("zod");
var props7 = {
  replace: import_zod7.z.union([
    import_zod7.z.array(import_zod7.z.string()),
    import_zod7.z.array(import_zod7.z.boolean()),
    import_zod7.z.object({
      to: import_zod7.z.string(),
      from: import_zod7.z.string(),
      preserveGeometry: import_zod7.z.boolean().optional()
    })
  ]).describe(JSON.stringify({
    text: "Uses generative AI to replace parts of your image with something else.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_replace"
  })).optional()
};
var assetTypes7 = ["image", "images"];
function plugin7(props20) {
  const { cldAsset, options } = props20;
  const { replace = null } = options;
  if (replace) {
    let from, to, preserveGeometry = false;
    if (Array.isArray(replace)) {
      from = replace[0];
      to = replace[1];
      preserveGeometry = replace[2] || false;
    } else {
      from = replace.from;
      to = replace.to;
      preserveGeometry = replace.preserveGeometry || false;
    }
    const properties = [`e_gen_replace:from_${from}`, `to_${to}`];
    if (preserveGeometry) {
      properties.push(`preserve-geometry_${preserveGeometry}`);
    }
    cldAsset.effect(properties.join(";"));
  }
  return {};
}

// src/plugins/named-transformations.ts
var named_transformations_exports = {};
__export(named_transformations_exports, {
  assetTypes: () => assetTypes8,
  plugin: () => plugin8,
  props: () => props8,
  strict: () => strict
});
var import_zod8 = require("zod");
var NamedTransformationSchema = import_zod8.z.string();
var props8 = {
  namedTransformations: import_zod8.z.union([
    NamedTransformationSchema,
    import_zod8.z.array(NamedTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Named transformations to apply to asset.",
    url: "https://cloudinary.com/documentation/image_transformations#named_transformations"
  })).optional(),
  /**
   * @deprecated use {@link `namedTransformations`} instead
   */
  transformations: import_zod8.z.union([
    NamedTransformationSchema,
    import_zod8.z.array(NamedTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Deprecated: use namedTransformations instead",
    url: "https://cloudinary.com/documentation/image_transformations#named_transformations"
  })).optional()
};
var assetTypes8 = ["image", "images", "video", "videos"];
var strict = true;
function plugin8(props20) {
  const { cldAsset, options } = props20;
  const { transformations, namedTransformations } = options;
  if (transformations && process.env.NODE_ENVIRONMENT === "development") {
    console.warn("The transformations prop is deprecated. Please use namedTransformations instead.");
  }
  let _namedTransformations = namedTransformations || transformations || [];
  if (!Array.isArray(_namedTransformations)) {
    _namedTransformations = [_namedTransformations];
  }
  _namedTransformations.forEach((transformation) => {
    cldAsset.addTransformation(`t_${transformation}`);
  });
  return {};
}

// src/plugins/overlays.ts
var overlays_exports = {};
__export(overlays_exports, {
  DEFAULT_TEXT_OPTIONS: () => DEFAULT_TEXT_OPTIONS,
  assetTypes: () => assetTypes9,
  plugin: () => plugin9,
  props: () => props9
});
var import_zod9 = require("zod");
var import_util3 = require("@cloudinary-util/util");
var overlayTextSchema = import_zod9.z.object({
  alignment: import_zod9.z.string().optional(),
  antialias: import_zod9.z.string().optional(),
  border: import_zod9.z.string().optional(),
  color: import_zod9.z.string().optional(),
  fontFamily: import_zod9.z.string().optional(),
  fontSize: import_zod9.z.number().optional(),
  fontStyle: import_zod9.z.union([
    import_zod9.z.string(),
    import_zod9.z.number()
  ]).optional(),
  fontWeight: import_zod9.z.string().optional(),
  hinting: import_zod9.z.union([
    import_zod9.z.string(),
    import_zod9.z.number()
  ]).optional(),
  letterSpacing: import_zod9.z.union([
    import_zod9.z.string(),
    import_zod9.z.number()
  ]).optional(),
  lineSpacing: import_zod9.z.union([
    import_zod9.z.string(),
    import_zod9.z.number()
  ]).optional(),
  stroke: import_zod9.z.string().optional(),
  text: import_zod9.z.string()
  // Required if using object format
});
var overlayPositionSchema = import_zod9.z.object({
  angle: angle.schema.optional(),
  gravity: gravity.schema.optional(),
  x: x.schema.optional(),
  y: y.schema.optional()
});
var overlaySchema = import_zod9.z.object({
  appliedEffects: import_zod9.z.array(import_zod9.z.object({})).optional(),
  appliedFlags: flags.schema.optional(),
  effects: import_zod9.z.array(import_zod9.z.object({})).optional(),
  crop: crop.schema.optional(),
  flags: flags.schema.optional(),
  height: height.schema.optional(),
  position: overlayPositionSchema.optional(),
  publicId: import_zod9.z.string().optional(),
  text: import_zod9.z.union([
    import_zod9.z.string(),
    overlayTextSchema
  ]).optional(),
  url: import_zod9.z.string().optional(),
  width: width.schema.optional()
});
var props9 = {
  overlay: overlaySchema.describe(JSON.stringify({
    text: "Image or text layer that is applied on top of the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  overlays: import_zod9.z.array(overlaySchema).describe(JSON.stringify({
    text: "Image or text layers that are applied on top of the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  text: import_zod9.z.string().describe(JSON.stringify({
    text: "Text to be overlaid on asset.",
    url: "https://cloudinary.com/documentation/image_transformations#transformation_url_structure"
  })).optional()
};
var assetTypes9 = ["image", "images", "video", "videos"];
var DEFAULT_TEXT_OPTIONS = {
  color: "black",
  fontFamily: "Arial",
  fontSize: 200,
  fontWeight: "bold"
};
function plugin9(props20) {
  const { cldAsset, options } = props20;
  const { text: text2, overlays = [] } = options;
  const type = "overlay";
  const typeQualifier = "l";
  if (Array.isArray(overlays)) {
    overlays.forEach(applyOverlay);
  }
  if (typeof text2 === "string") {
    applyOverlay({
      text: Object.assign({}, DEFAULT_TEXT_OPTIONS, {
        text: text2
      })
    });
  } else if (typeof text2 === "object") {
    applyOverlay({
      text: Object.assign({}, DEFAULT_TEXT_OPTIONS, text2)
    });
  }
  function applyOverlay({ publicId, url, position: position2, text: text3, effects: layerEffects = [], appliedEffects = [], flags: layerFlags = [], appliedFlags = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasUrl = typeof url === "string";
    const hasText = typeof text3 === "object" || typeof text3 === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId && !hasUrl && !hasText) {
      console.warn(`An ${type} is missing Public ID, URL, or Text`);
      return;
    }
    let layerTransformation;
    if (hasText) {
      layerTransformation = `${typeQualifier}_text`;
    } else if (hasPublicId) {
      layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    } else if (hasUrl) {
      layerTransformation = `${typeQualifier}_fetch:${(0, import_util3.encodeBase64)(url)}`;
    }
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!(0, import_util3.objectHasKey)(primary, key))
        return;
      const { qualifier, converters } = primary[key];
      const transformation = constructTransformation({
        qualifier,
        value: options2[key],
        converters
      });
      if (transformation) {
        primary2.push(transformation);
      }
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          primary2.push(transformation);
        }
      });
    });
    appliedEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    });
    const activeLayerFlags = Array.isArray(layerFlags) ? layerFlags : [layerFlags];
    activeLayerFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      primary2.push(`fl_${flag}`);
    });
    const activeAppliedFlags = Array.isArray(appliedFlags) ? appliedFlags : [appliedFlags];
    activeAppliedFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      applied.push(`fl_${flag}`);
    });
    if (hasText) {
      if (typeof text3 === "string") {
        text3 = {
          ...DEFAULT_TEXT_OPTIONS,
          text: text3
        };
      }
      const textTransformations = [];
      if (typeof text3 === "object") {
        const textOptions = Object.keys(text3).filter((key) => (0, import_util3.objectHasKey)(text, key)).map((key) => {
          const value = text3 && (0, import_util3.objectHasKey)(text3, key) && text3[key];
          return {
            ...text[key],
            key,
            value,
            order: text[key].order || 99
          };
        });
        const sortedTextOptions = (0, import_util3.sortByKey)(textOptions, "order");
        for (const textOption of sortedTextOptions) {
          const { key, value, qualifier, location, converters } = textOption;
          let textValue = value;
          converters?.forEach(({ test, convert }) => {
            if (!test(value))
              return;
            textValue = convert(value);
          });
          if (location === "primary") {
            primary2.push(`${qualifier}_${textValue}`);
          } else if (qualifier === "self") {
            textTransformations.push(key);
          } else if (qualifier) {
            textTransformations.push(`${qualifier}_${textValue}`);
          } else {
            textTransformations.push(textValue);
          }
        }
      }
      const specialCharacters = {
        ".": "%2E",
        ",": "%2C",
        "/": "%2F"
      };
      let layerText = text3?.text || "";
      if (typeof layerText === "string") {
        Object.keys(specialCharacters)?.forEach((character) => {
          layerText = layerText?.replace(character, specialCharacters[character]);
        });
      }
      layerTransformation = `${layerTransformation}:${textTransformations.join("_")}:${layerText}`;
    }
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!(0, import_util3.objectHasKey)(position, key) || !(0, import_util3.objectHasKey)(position2, key))
          return;
        const { qualifier, converters } = position[key];
        const transformation = constructTransformation({
          qualifier,
          value: position2[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    }
    if (primary2.length > 0) {
      layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    }
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/raw-transformations.ts
var raw_transformations_exports = {};
__export(raw_transformations_exports, {
  assetTypes: () => assetTypes10,
  plugin: () => plugin10,
  props: () => props10
});
var import_zod10 = require("zod");
var RawTransformationSchema = import_zod10.z.string();
var props10 = {
  rawTransformations: import_zod10.z.union([
    RawTransformationSchema,
    import_zod10.z.array(RawTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Array of transformation parameters using the Cloudinary URL API to apply to an asset.",
    url: "https://cloudinary.com/documentation/transformation_reference"
  })).optional()
};
var assetTypes10 = ["image", "images", "video", "videos"];
function plugin10(props20) {
  const { cldAsset, options } = props20;
  let { rawTransformations = [] } = options;
  if (!Array.isArray(rawTransformations)) {
    rawTransformations = [rawTransformations];
  }
  rawTransformations.forEach((transformation) => {
    cldAsset.addTransformation(transformation);
  });
  return {};
}

// src/plugins/recolor.ts
var recolor_exports = {};
__export(recolor_exports, {
  assetTypes: () => assetTypes11,
  plugin: () => plugin11,
  props: () => props11
});
var import_zod11 = require("zod");
var imageOptionsRecolorPromptSchema = import_zod11.z.union([
  import_zod11.z.string(),
  import_zod11.z.array(import_zod11.z.string())
]);
var imageOptionsRecolorSchema = import_zod11.z.object({
  prompt: imageOptionsRecolorPromptSchema.optional(),
  to: import_zod11.z.string().optional(),
  multiple: import_zod11.z.boolean().optional()
});
var props11 = {
  recolor: import_zod11.z.union([
    imageOptionsRecolorPromptSchema,
    imageOptionsRecolorSchema
  ]).describe(JSON.stringify({
    text: "Uses generative AI to recolor parts of your image, maintaining the relative shading.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_recolor"
  })).optional()
};
var assetTypes11 = ["image", "images"];
function plugin11(props20) {
  const { cldAsset, options } = props20;
  const { recolor } = options;
  const recolorOptions = {
    prompt: void 0,
    "to-color": void 0,
    multiple: void 0
  };
  if (Array.isArray(recolor)) {
    if (Array.isArray(recolor[0])) {
      recolorOptions.prompt = promptArrayToString(recolor[0]);
    } else {
      recolorOptions.prompt = recolor[0];
    }
    if (typeof recolor[1] === "string") {
      recolorOptions["to-color"] = recolor[1];
    }
  } else if (typeof recolor === "object") {
    if (typeof recolor.prompt === "string") {
      recolorOptions.prompt = recolor.prompt;
    } else if (Array.isArray(recolor.prompt)) {
      recolorOptions.prompt = promptArrayToString(recolor.prompt);
    }
    if (typeof recolor.to === "string") {
      recolorOptions["to-color"] = recolor.to;
    }
    if (recolor.multiple === true) {
      recolorOptions.multiple = `true`;
    }
  }
  const transformation = Object.entries(recolorOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_recolor:${transformation}`);
  }
  return {};
}

// src/plugins/remove.ts
var remove_exports = {};
__export(remove_exports, {
  assetTypes: () => assetTypes12,
  plugin: () => plugin12,
  props: () => props12
});
var import_zod12 = require("zod");
var imageOptionsRemovePromptSchema = import_zod12.z.union([
  import_zod12.z.string(),
  import_zod12.z.array(import_zod12.z.string())
]);
var imageOptionsRemoveSchema = import_zod12.z.object({
  prompt: imageOptionsRemovePromptSchema.optional(),
  region: import_zod12.z.union([
    import_zod12.z.array(import_zod12.z.number()),
    import_zod12.z.array(import_zod12.z.array(import_zod12.z.number()))
  ]).optional(),
  multiple: import_zod12.z.boolean().optional(),
  removeShadow: import_zod12.z.boolean().optional()
});
var props12 = {
  remove: import_zod12.z.union([
    imageOptionsRemovePromptSchema,
    imageOptionsRemoveSchema
  ]).describe(JSON.stringify({
    text: "Applies zooming and/or panning to an image, resulting in a video or animated image.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_zoompan"
  })).optional()
};
var assetTypes12 = ["image", "images"];
function plugin12(props20) {
  const { cldAsset, options } = props20;
  const { remove } = options;
  const removeOptions = {
    prompt: void 0,
    region: void 0,
    multiple: void 0,
    "remove-shadow": void 0
  };
  if (typeof remove === "string") {
    removeOptions.prompt = remove;
  } else if (Array.isArray(remove)) {
    removeOptions.prompt = promptArrayToString(remove);
  } else if (typeof remove === "object") {
    const hasPrompt = typeof remove.prompt === "string" || Array.isArray(remove.prompt);
    const hasRegion = Array.isArray(remove.region);
    if (hasPrompt && hasRegion) {
      throw new Error("Invalid remove options: you can not have both a prompt and a region. More info: https://cloudinary.com/documentation/transformation_reference#e_gen_remove");
    }
    if (typeof remove.prompt === "string") {
      removeOptions.prompt = remove.prompt;
    } else if (Array.isArray(remove.prompt)) {
      removeOptions.prompt = promptArrayToString(remove.prompt);
    }
    if (Array.isArray(remove.region)) {
      removeOptions.region = regionArrayToString(remove.region);
    }
    if (remove.multiple === true) {
      removeOptions.multiple = `true`;
    }
    if (remove.removeShadow === true) {
      removeOptions["remove-shadow"] = `true`;
    }
  }
  const transformation = Object.entries(removeOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_remove:${transformation}`);
  }
  return {};
}
function regionArrayToString(regionArray) {
  const indexes = {
    0: "x",
    1: "y",
    2: "w",
    3: "h"
  };
  const regionString = regionArray.map((region, index) => {
    if (Array.isArray(region)) {
      return regionArrayToString(region);
    }
    const key = indexes[index];
    return `${key}_${region}`;
  }).join(";");
  return `(${regionString})`;
}

// src/plugins/remove-background.ts
var remove_background_exports = {};
__export(remove_background_exports, {
  assetTypes: () => assetTypes13,
  plugin: () => plugin13,
  props: () => props13
});
var import_zod13 = require("zod");
var props13 = {
  removeBackground: import_zod13.z.boolean().describe(JSON.stringify({
    text: "Removes the background of an image using the Cloudinary AI Background Removal Add-On (Required).",
    url: "https://cloudinary.com/documentation/cloudinary_ai_background_removal_addon"
  })).optional()
};
var assetTypes13 = ["image", "images"];
function plugin13(props20) {
  const { cldAsset, options } = props20;
  const { removeBackground = false } = options;
  if (removeBackground) {
    cldAsset.effect("e_background_removal");
  }
  return {};
}

// src/plugins/restore.ts
var restore_exports = {};
__export(restore_exports, {
  assetTypes: () => assetTypes14,
  plugin: () => plugin14,
  props: () => props14
});
var import_zod14 = require("zod");
var props14 = {
  restore: import_zod14.z.boolean().describe(JSON.stringify({
    text: "Uses generative AI to restore details in poor quality images or images that may have become degraded through repeated processing and compression.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_restore"
  })).optional()
};
var assetTypes14 = ["image", "images"];
function plugin14(props20) {
  const { cldAsset, options } = props20;
  const { restore = false } = options;
  if (restore) {
    cldAsset.effect("e_gen_restore");
  }
  return {};
}

// src/plugins/sanitize.ts
var sanitize_exports = {};
__export(sanitize_exports, {
  assetTypes: () => assetTypes15,
  plugin: () => plugin15,
  props: () => props15
});
var import_zod15 = require("zod");
var props15 = {
  sanitize: import_zod15.z.boolean().describe(JSON.stringify({
    text: "Runs a sanitizer on SVG images.",
    url: "https://cloudinary.com/documentation/transformation_reference#fl_sanitize"
  })).optional()
};
var assetTypes15 = ["image", "images"];
function plugin15(props20) {
  const { cldAsset, options } = props20;
  const { sanitize = true } = options;
  const shouldApplySanitizer = sanitize && (options.format === "svg" || cldAsset.publicID.endsWith(".svg"));
  if (shouldApplySanitizer) {
    cldAsset.effect("fl_sanitize");
  }
  return {};
}

// src/plugins/seo.ts
var seo_exports = {};
__export(seo_exports, {
  assetTypes: () => assetTypes16,
  plugin: () => plugin16,
  props: () => props16
});
var import_zod16 = require("zod");
var props16 = {
  seoSuffix: import_zod16.z.string().describe(JSON.stringify({
    text: "Configures the URL to include an SEO-friendly suffix in the URL",
    url: "https://cloudinary.com/documentation/advanced_url_delivery_options#seo_friendly_media_asset_urls"
  })).optional()
};
var assetTypes16 = ["image", "images", "video", "videos"];
function plugin16(props20) {
  const { cldAsset, options } = props20;
  const { seoSuffix } = options;
  if (typeof seoSuffix === "string") {
    if (options.deliveryType === "fetch") {
      console.warn("SEO suffix is not supported with a delivery type of fetch");
    } else {
      cldAsset.setSuffix(seoSuffix);
    }
  }
  return {};
}

// src/plugins/underlays.ts
var underlays_exports = {};
__export(underlays_exports, {
  assetTypes: () => assetTypes17,
  plugin: () => plugin17,
  props: () => props17
});
var import_zod17 = require("zod");
var import_util4 = require("@cloudinary-util/util");
var underlayPositionSchema = import_zod17.z.object({
  angle: angle.schema.optional(),
  gravity: gravity.schema.optional(),
  x: x.schema.optional(),
  y: y.schema.optional()
});
var underlaySchema = import_zod17.z.object({
  appliedEffects: import_zod17.z.array(import_zod17.z.object({})).optional(),
  appliedFlags: flags.schema.optional(),
  effects: import_zod17.z.array(import_zod17.z.object({})).optional(),
  crop: crop.schema.optional(),
  flags: flags.schema.optional(),
  height: height.schema.optional(),
  position: underlayPositionSchema.optional(),
  publicId: import_zod17.z.string().optional(),
  type: import_zod17.z.string().optional(),
  url: import_zod17.z.string().optional(),
  width: width.schema.optional()
});
var props17 = {
  underlay: import_zod17.z.string().describe(JSON.stringify({
    text: "Public ID of image that is applied under the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  underlays: import_zod17.z.array(underlaySchema).describe(JSON.stringify({
    text: "Image layers that are applied under the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional()
};
var assetTypes17 = ["image", "images", "video", "videos"];
function plugin17(props20) {
  const { cldAsset, options } = props20;
  const { underlay, underlays = [] } = options;
  const typeQualifier = "u";
  if (Array.isArray(underlays)) {
    underlays.forEach(applyUnderlay);
  }
  if (typeof underlay === "string") {
    const underlayOptions = {
      publicId: underlay,
      crop: "fill",
      width: "1.0",
      height: "1.0",
      flags: ["relative"]
    };
    applyUnderlay(underlayOptions);
  }
  function applyUnderlay({ publicId, type, position: position2, effects: layerEffects = [], flags: layerFlags = [], appliedFlags = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId) {
      console.warn(`An ${type} is missing a Public ID`);
      return;
    }
    let layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!(0, import_util4.objectHasKey)(primary, key))
        return;
      const { qualifier } = primary[key];
      primary2.push(`${qualifier}_${options2[key]}`);
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        if (!(0, import_util4.objectHasKey)(primary, key))
          return;
        const { qualifier } = primary[key];
        primary2.push(`${qualifier}_${effect[key]}`);
      });
    });
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!(0, import_util4.objectHasKey)(position, key))
          return;
        const { qualifier } = position[key];
        applied.push(`${qualifier}_${position2[key]}`);
      });
    }
    const activeLayerFlags = Array.isArray(layerFlags) ? layerFlags : [layerFlags];
    activeLayerFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      primary2.push(`fl_${flag}`);
    });
    const activeAppliedFlags = Array.isArray(appliedFlags) ? appliedFlags : [appliedFlags];
    activeAppliedFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      applied.push(`fl_${flag}`);
    });
    layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/version.ts
var version_exports = {};
__export(version_exports, {
  assetTypes: () => assetTypes18,
  plugin: () => plugin18,
  props: () => props18
});
var import_zod18 = require("zod");
var props18 = {
  version: import_zod18.z.union([
    import_zod18.z.number(),
    import_zod18.z.string()
  ]).describe(JSON.stringify({
    text: "Custom version number to apply to asset URL.",
    url: "https://cloudinary.com/documentation/advanced_url_delivery_options#asset_versions"
  })).optional()
};
var assetTypes18 = ["image", "images", "video", "videos"];
function plugin18(props20) {
  const { cldAsset, options } = props20;
  const { version } = options;
  if (typeof version === "string" || typeof version === "number") {
    cldAsset.setVersion(`${version}`.replace("v", ""));
  }
  return {};
}

// src/plugins/zoompan.ts
var zoompan_exports = {};
__export(zoompan_exports, {
  assetTypes: () => assetTypes19,
  plugin: () => plugin19,
  props: () => props19
});
var import_zod19 = require("zod");
var props19 = {
  zoompan: import_zod19.z.union([
    import_zod19.z.string(),
    import_zod19.z.boolean(),
    import_zod19.z.object({
      loop: import_zod19.z.union([import_zod19.z.string(), import_zod19.z.boolean()]),
      options: import_zod19.z.string()
    })
  ]).describe(JSON.stringify({
    text: "Applies zooming and/or panning to an image, resulting in a video or animated image.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_zoompan"
  })).optional()
};
var assetTypes19 = ["image", "images"];
function plugin19(props20) {
  const { cldAsset, options } = props20;
  const { zoompan = false } = options;
  const overrides = {
    format: void 0
  };
  if (zoompan === true) {
    cldAsset.effect("e_zoompan");
  } else if (typeof zoompan === "string") {
    if (zoompan === "loop") {
      cldAsset.effect("e_zoompan");
      cldAsset.effect("e_loop");
    } else {
      cldAsset.effect(`e_zoompan:${zoompan}`);
    }
  } else if (typeof zoompan === "object") {
    let zoompanEffect = "e_zoompan";
    if (typeof zoompan.options === "string") {
      zoompanEffect = `${zoompanEffect}${zoompan.options}`;
    }
    cldAsset.effect(zoompanEffect);
    let loopEffect;
    if (zoompan.loop === true) {
      loopEffect = "e_loop";
    } else if (typeof zoompan.loop === "string") {
      loopEffect = `e_loop${zoompan.loop}`;
    }
    if (loopEffect) {
      cldAsset.effect(loopEffect);
    }
  }
  if (zoompan !== false) {
    overrides.format = "auto:animated";
  }
  return {
    options: overrides
  };
}

// src/types/asset.ts
var import_zod20 = require("zod");
var assetOptionsSchema = import_zod20.z.object({
  assetType: import_zod20.z.string().default("image").describe(JSON.stringify({
    text: "The type of asset to deliver.",
    url: "https://cloudinary.com/documentation/image_transformations#transformation_url_structure"
  })).optional(),
  deliveryType: import_zod20.z.string().default("upload").describe(JSON.stringify({
    text: "Delivery method of the asset.",
    url: "https://cloudinary.com/documentation/image_transformations#delivery_types"
  })).optional(),
  dpr: import_zod20.z.union([import_zod20.z.string(), import_zod20.z.number()]).describe(JSON.stringify({
    text: "Delivery method of the asset.",
    url: "https://cloudinary.com/documentation/image_transformations#delivery_types"
  })).optional(),
  format: import_zod20.z.string().default("auto").describe(JSON.stringify({
    text: "Converts (if necessary) and delivers an asset in the specified format.",
    url: "https://cloudinary.com/documentation/transformation_reference#f_format"
  })).optional(),
  height: import_zod20.z.union([import_zod20.z.string(), import_zod20.z.number()]).describe(JSON.stringify({
    text: "Height of the given asset."
  })).optional(),
  quality: import_zod20.z.union([import_zod20.z.number(), import_zod20.z.string()]).default("auto").describe(JSON.stringify({
    text: "Quality of the delivered asset",
    url: "https://cloudinary.com/documentation/transformation_reference#q_quality"
  })).optional(),
  src: import_zod20.z.string().describe(JSON.stringify({
    text: "Cloudinary Public ID or versioned Cloudinary URL (/v1234/)"
  })),
  strictTransformations: import_zod20.z.boolean().describe(JSON.stringify({
    text: "Gives you the ability to have more control over what transformations are permitted to be used from your Cloudinary account.",
    url: "https://cloudinary.com/documentation/control_access_to_media#strict_transformations"
  })).optional(),
  width: import_zod20.z.union([import_zod20.z.string(), import_zod20.z.number()]).describe(JSON.stringify({
    text: "Width of the given asset."
  })).optional(),
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props2,
  ...props4,
  ...props5,
  ...props8,
  ...props9,
  ...props10,
  ...props13,
  ...props15,
  ...props16,
  ...props17,
  ...props18
});

// src/types/image.ts
var import_zod21 = require("zod");
var imageOptionsSchema = assetOptionsSchema.merge(import_zod21.z.object({
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props3,
  ...props6,
  ...props11,
  ...props12,
  ...props7,
  ...props14,
  ...props19
}));

// src/types/video.ts
var import_zod22 = require("zod");
var videoOptionsSchema = assetOptionsSchema.merge(import_zod22.z.object({
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props
}));

// src/types/analytics.ts
var import_zod23 = require("zod");
var analyticsOptionsSchema = import_zod23.z.any();

// src/types/config.ts
var import_zod24 = require("zod");
var configOptionsSchema = import_zod24.z.any();

// src/lib/cloudinary.ts
var transformationPlugins = [
  // Some features *must* be the first transformation applied
  // thus their plugins *must* come first in the chain
  recolor_exports,
  remove_exports,
  remove_background_exports,
  replace_exports,
  restore_exports,
  // Raw transformations should always come before
  // other arguments to avoid conflicting with
  // added options via the component
  raw_transformations_exports,
  abr_exports,
  cropping_exports,
  default_image_exports,
  effects_exports,
  fill_background_exports,
  flags_exports,
  overlays_exports,
  sanitize_exports,
  named_transformations_exports,
  seo_exports,
  underlays_exports,
  version_exports,
  zoompan_exports
];
var constructUrlPropsSchema = import_zod25.z.object({
  analytics: import_zod25.z.union([
    analyticsOptionsSchema,
    import_zod25.z.boolean()
  ]).describe(JSON.stringify({
    text: "Tech, dependency, and feature identifiers for tracking SDK usage related to Cloudinary.",
    path: "/url-loader/analyticsoptions"
  })).optional(),
  config: configOptionsSchema.describe(JSON.stringify({
    text: "Configuration parameters for environment and Cloudinary account.",
    url: "https://cloudinary.com/documentation/cloudinary_sdks#configuration_parameters",
    path: "/url-loader/analyticsoptions"
  })).optional(),
  options: import_zod25.z.union([
    assetOptionsSchema,
    imageOptionsSchema,
    videoOptionsSchema
  ]).describe(JSON.stringify({
    text: "Asset options (Image or Video) that define delivery URL including public ID and transformations.",
    path: "/url-loader/assetoptions"
  }))
});
function constructCloudinaryUrl({ options, config = {}, analytics }) {
  if (analytics === false) {
    if (typeof config?.url === "undefined") {
      config.url = {};
    }
    config.url.analytics = false;
  }
  const cld = new import_url_gen.Cloudinary(config);
  if (typeof options?.src !== "string") {
    throw Error(`Failed to construct Cloudinary URL: Missing source (src) in options`);
  }
  if (!options?.assetType) {
    options.assetType = "image";
  }
  const propsCheck = [];
  transformationPlugins.forEach(({ props: props20 }) => {
    const pluginProps = Object.keys(props20);
    pluginProps.forEach((prop) => {
      if (propsCheck.includes(prop)) {
        throw new Error(`Option ${prop} already exists!`);
      }
      propsCheck.push(prop);
    });
  });
  const parsedOptions = {};
  let publicId;
  if (typeof options.src === "string" && /^https?:\/\//.test(options.src)) {
    try {
      const parts = (0, import_util5.parseUrl)(options.src);
      publicId = parts?.publicId;
      parsedOptions.seoSuffix = parts?.seoSuffix;
      parsedOptions.version = parts?.version;
    } catch (e) {
    }
  }
  if (!publicId) {
    publicId = options.src;
  }
  Object.keys(parsedOptions).forEach((key) => {
    if ((0, import_util5.objectHasKey)(options, key))
      return;
    options[key] = parsedOptions[key];
  });
  let cldAsset = void 0;
  if (["image", "images"].includes(options.assetType)) {
    cldAsset = cld.image(publicId);
  } else if (["video", "videos"].includes(options.assetType)) {
    cldAsset = cld.video(publicId);
  }
  if (typeof cldAsset === "undefined") {
    throw new Error("Invalid asset type.");
  }
  const pluginEffects = {};
  transformationPlugins.forEach(({ plugin: plugin20, assetTypes: assetTypes20, props: props20, strict: strict2 }) => {
    const supportedAssetType = typeof options?.assetType !== "undefined" && assetTypes20.includes(options?.assetType);
    const pluginProps = Object.keys(props20);
    const optionsKeys = Object.keys(options);
    const attemptedUse = pluginProps.map((prop) => optionsKeys.includes(prop)).filter((isUsed) => !!isUsed).length > 0;
    if (!supportedAssetType) {
      if (attemptedUse) {
        console.warn(`One of the following props [${pluginProps.join(", ")}] was used with an unsupported asset type [${options?.assetType}]`);
      }
      return;
    }
    if (options.strictTransformations && !strict2) {
      if (attemptedUse) {
        console.warn(`One of the following props [${pluginProps.join(", ")}] was used that is not supported with Strict Transformations.`);
      }
      return;
    }
    const results = plugin20({
      cldAsset,
      options
    });
    const { options: pluginOptions } = results || { options: void 0 };
    if (pluginOptions?.format && options) {
      pluginEffects.format = pluginOptions.format;
    }
    if (pluginOptions?.width && options) {
      pluginEffects.resize = {
        width: pluginOptions?.width
      };
    }
  });
  if (pluginEffects?.resize && !options.strictTransformations) {
    const { width: width2, crop: crop2 = "limit" } = pluginEffects.resize;
    cldAsset.effect(`c_${crop2},w_${width2}`);
  }
  cldAsset.setDeliveryType(options?.deliveryType || "upload");
  if (!options.strictTransformations) {
    if (options?.dpr) {
      let dpr = options.dpr;
      if (typeof dpr === "number") {
        dpr = dpr.toFixed(1);
      }
      cldAsset.addTransformation(`dpr_${dpr}`);
    }
    if (options?.format !== "default") {
      cldAsset.format(options?.format || pluginEffects?.format || "auto");
    }
    if (options?.quality !== "default") {
      cldAsset.quality(options?.quality || "auto");
    }
  }
  return cldAsset.toURL({
    trackedAnalytics: analytics
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  constructCloudinaryUrl,
  effects,
  position,
  primary,
  text,
  transformationPlugins
});
