'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shared = require('@edgestore/shared');
var logger = require('../../../logger-dcb682ae.js');
var providers_edgestore_index = require('../../../providers/edgestore/index.js');
var shared$1 = require('../../../shared-7c700083.js');
require('../../../index-4491caf0.js');
require('@panva/hkdf');
require('cookie');
require('jose');
require('uuid');

function createEdgeStoreNextHandler(config) {
    const { provider = providers_edgestore_index.EdgeStoreProvider() } = config;
    const log = new logger.Logger(config.logLevel);
    globalThis._EDGE_STORE_LOGGER = log;
    log.debug('Creating Edge Store Next handler (pages adapter)');
    return async (req, res)=>{
        try {
            if (!('json' in res)) throw new shared.EdgeStoreError({
                message: 'Error running the pages adapter. Make sure you are importing the correct adapter in your router configuration',
                code: 'SERVER_ERROR'
            });
            if (req.url?.includes?.('/health')) {
                res.send('OK');
            } else if (req.url?.includes?.('/init')) {
                let ctx = {};
                try {
                    ctx = 'createContext' in config ? await config.createContext({
                        req,
                        res
                    }) : {};
                } catch (err) {
                    throw new shared.EdgeStoreError({
                        message: 'Error creating context',
                        code: 'CREATE_CONTEXT_ERROR',
                        cause: err instanceof Error ? err : undefined
                    });
                }
                const { newCookies, token, baseUrl } = await shared$1.init({
                    ctx,
                    provider,
                    router: config.router
                });
                res.setHeader('Set-Cookie', newCookies);
                res.json({
                    token,
                    baseUrl
                });
            } else if (req.url?.includes?.('/request-upload')) {
                res.json(await shared$1.requestUpload({
                    provider,
                    router: config.router,
                    body: req.body,
                    ctxToken: req.cookies['edgestore-ctx']
                }));
            } else if (req.url?.includes?.('/request-upload-parts')) {
                res.json(await shared$1.requestUploadParts({
                    provider,
                    router: config.router,
                    body: req.body,
                    ctxToken: req.cookies['edgestore-ctx']
                }));
            } else if (req.url?.includes?.('/complete-multipart-upload')) {
                await shared$1.completeMultipartUpload({
                    provider,
                    router: config.router,
                    body: req.body,
                    ctxToken: req.cookies['edgestore-ctx']
                });
                res.status(200).end();
            } else if (req.url?.includes?.('/confirm-upload')) {
                res.json(await shared$1.confirmUpload({
                    provider,
                    router: config.router,
                    body: req.body,
                    ctxToken: req.cookies['edgestore-ctx']
                }));
            } else if (req.url?.includes?.('/delete-file')) {
                res.json(await shared$1.deleteFile({
                    provider,
                    router: config.router,
                    body: req.body,
                    ctxToken: req.cookies['edgestore-ctx']
                }));
            } else if (req.url?.includes?.('/proxy-file')) {
                const { url } = req.query;
                if (typeof url === 'string') {
                    const proxyRes = await fetch(url, {
                        headers: {
                            cookie: req.headers.cookie ?? ''
                        }
                    });
                    const data = await proxyRes.arrayBuffer();
                    res.setHeader('Content-Type', proxyRes.headers.get('Content-Type') ?? 'application/octet-stream');
                    res.end(Buffer.from(data));
                } else {
                    res.status(400).end();
                }
            } else {
                res.status(404).end();
            }
        } catch (err) {
            if (err instanceof shared.EdgeStoreError) {
                log[err.level](err.formattedMessage());
                if (err.cause) log[err.level](err.cause);
                res.status(shared.EDGE_STORE_ERROR_CODES[err.code]).json(err.formattedJson());
            } else {
                log.error(err);
                res.status(500).send(new shared.EdgeStoreError({
                    message: 'Internal Server Error',
                    code: 'SERVER_ERROR'
                }).formattedJson());
            }
        }
    };
}

exports.createEdgeStoreNextHandler = createEdgeStoreNextHandler;
