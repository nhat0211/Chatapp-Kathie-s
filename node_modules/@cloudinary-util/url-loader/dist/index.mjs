var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/lib/cloudinary.ts
import { Cloudinary } from "@cloudinary/url-gen";
import { parseUrl, objectHasKey as objectHasKey4 } from "@cloudinary-util/util";

// src/plugins/cropping.ts
var cropping_exports = {};
__export(cropping_exports, {
  assetTypes: () => assetTypes,
  normalizeNumberParameter: () => normalizeNumberParameter,
  plugin: () => plugin,
  props: () => props
});
var cropsAspectRatio = ["crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsGravityAuto = ["crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsWithZoom = ["crop", "thumb"];
var props = [
  "aspectRatio",
  "crop",
  "gravity",
  "zoom"
];
var assetTypes = ["image", "images", "video", "videos"];
function normalizeNumberParameter(param) {
  if (typeof param !== "string")
    return param;
  return parseInt(param);
}
function plugin(props20) {
  const { cldAsset, options } = props20;
  const {
    aspectRatio,
    width: defaultWidth,
    height: defaultHeight,
    widthResize: defaultWidthResize,
    crop = "limit"
  } = options;
  const overrides = {
    width: void 0
  };
  let height = normalizeNumberParameter(defaultHeight);
  let width = normalizeNumberParameter(defaultWidth);
  let widthResize = normalizeNumberParameter(defaultWidthResize);
  const hasDefinedDimensions = height || width;
  const hasValidAspectRatio = aspectRatio && cropsAspectRatio.includes(crop);
  let transformationString = "";
  if (crop && (hasDefinedDimensions || hasValidAspectRatio)) {
    transformationString = `c_${crop}`;
  }
  if (hasValidAspectRatio) {
    transformationString = `${transformationString},ar_${aspectRatio}`;
  }
  if (width) {
    transformationString = `${transformationString},w_${width}`;
  }
  if (!options.gravity && cropsGravityAuto.includes(crop)) {
    options.gravity = "auto";
  }
  if (!["limit"].includes(crop) && typeof height === "number") {
    transformationString = `${transformationString},h_${height}`;
  }
  if (options.gravity) {
    if (options.gravity === "auto" && !cropsGravityAuto.includes(crop)) {
      console.warn(`Auto gravity can only be used with crop modes: ${cropsGravityAuto.join(", ")}. Not applying gravity.`);
    } else {
      transformationString = `${transformationString},g_${options.gravity}`;
    }
  }
  if (options.zoom) {
    if (options.zoom === "auto" && !cropsWithZoom.includes(crop)) {
      console.warn(`Zoom can only be used with crop modes: ${cropsWithZoom.join(", ")}. Not applying zoom.`);
    } else {
      transformationString = `${transformationString},z_${options.zoom}`;
    }
  }
  cldAsset.effect(transformationString);
  if (widthResize) {
    overrides.width = widthResize;
  }
  return {
    options: overrides
  };
}

// src/plugins/default-image.ts
var default_image_exports = {};
__export(default_image_exports, {
  assetTypes: () => assetTypes2,
  plugin: () => plugin2,
  props: () => props2
});
import { getFormat } from "@cloudinary-util/util";
var props2 = ["default"];
var assetTypes2 = ["image", "images"];
function plugin2(props20) {
  const { cldAsset, options } = props20;
  const { defaultImage } = options;
  if (typeof defaultImage === "string") {
    if (!getFormat(defaultImage)) {
      console.warn(`The defaultImage prop may be missing a format and must include it along with the public ID. (Ex: myimage.jpg)`);
    }
    const defaultImageId = defaultImage.replace(/\//g, ":");
    cldAsset.addTransformation(`d_${defaultImageId}`);
  }
  return {};
}

// src/plugins/effects.ts
var effects_exports = {};
__export(effects_exports, {
  assetTypes: () => assetTypes3,
  plugin: () => plugin3,
  props: () => props3
});

// src/constants/qualifiers.ts
import { testColorIsHex, convertColorHexToRgb } from "@cloudinary-util/util";
var convertersColors = [
  {
    test: testColorIsHex,
    convert: convertColorHexToRgb
  }
];
var primary = {
  aspectRatio: {
    qualifier: "ar"
  },
  crop: {
    qualifier: "c"
  },
  gravity: {
    qualifier: "g"
  },
  height: {
    qualifier: "h"
  },
  width: {
    qualifier: "w"
  }
};
var position = {
  angle: {
    qualifier: "a"
  },
  gravity: {
    qualifier: "g"
  },
  x: {
    qualifier: "x"
  },
  y: {
    qualifier: "y"
  }
};
var text = {
  alignment: {
    qualifier: false,
    order: 6
  },
  antialias: {
    qualifier: "antialias"
  },
  border: {
    qualifier: "bo",
    location: "primary"
  },
  color: {
    qualifier: "co",
    location: "primary",
    converters: convertersColors
  },
  fontFamily: {
    qualifier: false,
    order: 1
  },
  fontSize: {
    qualifier: false,
    order: 2
  },
  fontStyle: {
    qualifier: false,
    order: 4
  },
  fontWeight: {
    qualifier: false,
    order: 3
  },
  hinting: {
    qualifier: "hinting"
  },
  letterSpacing: {
    qualifier: "letter_spacing"
  },
  lineSpacing: {
    qualifier: "line_spacing"
  },
  stroke: {
    qualifier: "self",
    order: 7
  },
  textDecoration: {
    qualifier: false,
    order: 5
  }
};
var effects = {
  art: {
    prefix: "e",
    qualifier: "art"
  },
  autoBrightness: {
    prefix: "e",
    qualifier: "auto_brightness"
  },
  autoColor: {
    prefix: "e",
    qualifier: "auto_color"
  },
  autoContrast: {
    prefix: "e",
    qualifier: "auto_contrast"
  },
  assistColorblind: {
    prefix: "e",
    qualifier: "assist_colorblind"
  },
  background: {
    qualifier: "b"
  },
  blackwhite: {
    prefix: "e",
    qualifier: "blackwhite"
  },
  blur: {
    prefix: "e",
    qualifier: "blur"
  },
  blurFaces: {
    prefix: "e",
    qualifier: "blur_faces"
  },
  blurRegion: {
    prefix: "e",
    qualifier: "blur_region"
  },
  border: {
    qualifier: "bo"
  },
  brightness: {
    prefix: "e",
    qualifier: "brightness"
  },
  brightnessHSB: {
    prefix: "e",
    qualifier: "brightness_hsb"
  },
  cartoonify: {
    prefix: "e",
    qualifier: "cartoonify"
  },
  color: {
    qualifier: "co",
    converters: convertersColors
  },
  colorize: {
    prefix: "e",
    qualifier: "colorize"
  },
  contrast: {
    prefix: "e",
    qualifier: "contrast"
  },
  distort: {
    prefix: "e",
    qualifier: "distort"
  },
  fillLight: {
    prefix: "e",
    qualifier: "fill_light"
  },
  gamma: {
    prefix: "e",
    qualifier: "gamma"
  },
  gradientFade: {
    prefix: "e",
    qualifier: "gradient_fade"
  },
  grayscale: {
    prefix: "e",
    qualifier: "grayscale"
  },
  improve: {
    prefix: "e",
    qualifier: "improve"
  },
  multiply: {
    prefix: "e",
    qualifier: "multiply"
  },
  negate: {
    prefix: "e",
    qualifier: "negate"
  },
  oilPaint: {
    prefix: "e",
    qualifier: "oil_paint"
  },
  opacity: {
    qualifier: "o"
  },
  outline: {
    prefix: "e",
    qualifier: "outline"
  },
  overlay: {
    prefix: "e",
    qualifier: "overlay"
  },
  pixelate: {
    prefix: "e",
    qualifier: "pixelate"
  },
  pixelateFaces: {
    prefix: "e",
    qualifier: "pixelate_faces"
  },
  pixelateRegion: {
    prefix: "e",
    qualifier: "pixelate_region"
  },
  radius: {
    qualifier: "r"
  },
  redeye: {
    prefix: "e",
    qualifier: "redeye"
  },
  replaceColor: {
    prefix: "e",
    qualifier: "replace_color"
  },
  saturation: {
    prefix: "e",
    qualifier: "saturation"
  },
  screen: {
    prefix: "e",
    qualifier: "screen"
  },
  sepia: {
    prefix: "e",
    qualifier: "sepia"
  },
  shadow: {
    prefix: "e",
    qualifier: "shadow"
  },
  sharpen: {
    prefix: "e",
    qualifier: "sharpen"
  },
  shear: {
    prefix: "e",
    qualifier: "shear"
  },
  simulateColorblind: {
    prefix: "e",
    qualifier: "simulate_colorblind"
  },
  tint: {
    prefix: "e",
    qualifier: "tint"
  },
  trim: {
    prefix: "e",
    qualifier: "trim"
  },
  unsharpMask: {
    prefix: "e",
    qualifier: "unsharp_mask"
  },
  vectorize: {
    prefix: "e",
    qualifier: "vectorize"
  },
  vibrance: {
    prefix: "e",
    qualifier: "vibrance"
  },
  vignette: {
    prefix: "e",
    qualifier: "vignette"
  }
};
var flags = {
  animated: {
    prefix: "fl",
    qualifier: "animated"
  },
  anyFormat: {
    prefix: "fl",
    qualifier: "any_format"
  },
  apng: {
    prefix: "fl",
    qualifier: "apng"
  },
  attachment: {
    prefix: "fl",
    qualifier: "attachment"
  },
  awebp: {
    prefix: "fl",
    qualifier: "awebp"
  },
  clip: {
    prefix: "fl",
    qualifier: "clip"
  },
  clipEvenodd: {
    prefix: "fl",
    qualifier: "clip_evenodd"
  },
  cutter: {
    prefix: "fl",
    qualifier: "cutter"
  },
  draco: {
    prefix: "fl",
    qualifier: "draco"
  },
  forceIcc: {
    prefix: "fl",
    qualifier: "force_icc"
  },
  forceStrip: {
    prefix: "fl",
    qualifier: "force_strip"
  },
  getinfo: {
    prefix: "fl",
    qualifier: "getinfo"
  },
  group4: {
    prefix: "fl",
    qualifier: "group4"
  },
  hlsv3: {
    prefix: "fl",
    qualifier: "hlsv3"
  },
  ignoreAspectRatio: {
    prefix: "fl",
    qualifier: "ignore_aspect_ratio"
  },
  ignoreMaskChannels: {
    prefix: "fl",
    qualifier: "ignore_mask_channels"
  },
  immutableCache: {
    prefix: "fl",
    qualifier: "immutable_cache"
  },
  keepAttribution: {
    prefix: "fl",
    qualifier: "keep_attribution"
  },
  keepDar: {
    prefix: "fl",
    qualifier: "keep_dar"
  },
  keepIptc: {
    prefix: "fl",
    qualifier: "keep_iptc"
  },
  layerApply: {
    prefix: "fl",
    qualifier: "layer_apply"
  },
  lossy: {
    prefix: "fl",
    qualifier: "lossy"
  },
  mono: {
    prefix: "fl",
    qualifier: "mono"
  },
  noOverflow: {
    prefix: "fl",
    qualifier: "no_overflow"
  },
  noStream: {
    prefix: "fl",
    qualifier: "no_stream"
  },
  png8: {
    prefix: "fl",
    qualifier: "png8"
  },
  png24: {
    prefix: "fl",
    qualifier: "png24"
  },
  png32: {
    prefix: "fl",
    qualifier: "png32"
  },
  preserveTransparency: {
    prefix: "fl",
    qualifier: "preserve_transparency"
  },
  progressive: {
    prefix: "fl",
    qualifier: "progressive"
  },
  rasterize: {
    prefix: "fl",
    qualifier: "rasterize"
  },
  regionRelative: {
    prefix: "fl",
    qualifier: "region_relative"
  },
  relative: {
    prefix: "fl",
    qualifier: "relative",
    location: "primary"
  },
  replaceImage: {
    prefix: "fl",
    qualifier: "replace_image"
  },
  sanitize: {
    prefix: "fl",
    qualifier: "sanitize"
  },
  splice: {
    prefix: "fl",
    qualifier: "splice"
  },
  streamingAttachment: {
    prefix: "fl",
    qualifier: "streaming_attachment"
  },
  stripProfile: {
    prefix: "fl",
    qualifier: "strip_profile"
  },
  textDisallowOverflow: {
    prefix: "fl",
    qualifier: "text_disallow_overflow"
  },
  textNoTrim: {
    prefix: "fl",
    qualifier: "text_no_trim"
  },
  tif8Lzw: {
    prefix: "fl",
    qualifier: "tif8_lzw"
  },
  tiled: {
    prefix: "fl",
    qualifier: "tiled"
  },
  truncateTs: {
    prefix: "fl",
    qualifier: "truncate_ts"
  },
  waveform: {
    prefix: "fl",
    qualifier: "waveform"
  }
};
var video = {
  streamingProfile: {
    qualifier: "sp",
    location: "primary"
  }
};

// src/lib/transformations.ts
function constructTransformation({ prefix, qualifier, value, converters }) {
  let transformation = "";
  if (prefix) {
    transformation = `${prefix}_`;
  }
  let transformationValue = value;
  converters == null ? void 0 : converters.forEach(({ test, convert }) => {
    if (!test(transformationValue))
      return;
    transformationValue = convert(transformationValue);
  });
  if (transformationValue === true || transformationValue === "true") {
    return `${transformation}${qualifier}`;
  }
  if (typeof transformationValue === "string" || typeof transformationValue === "number") {
    if (prefix) {
      return `${transformation}${qualifier}:${transformationValue}`;
    } else {
      return `${qualifier}_${transformationValue}`;
    }
  }
}
function promptArrayToString(promptArray) {
  return `(${promptArray.join(";")})`;
}

// src/plugins/effects.ts
var props3 = [...Object.keys(effects), "effects"];
var assetTypes3 = ["image", "images", "video", "videos"];
function plugin3(props20) {
  const { cldAsset, options } = props20;
  const transformationStrings = constructTransformationString({
    effects,
    options
  });
  transformationStrings.filter((t) => !!t).forEach((transformation) => cldAsset.effect(transformation));
  ;
  if (Array.isArray(options == null ? void 0 : options.effects)) {
    options == null ? void 0 : options.effects.forEach((effectsSet) => {
      const transformationString = constructTransformationString({
        effects,
        options: effectsSet
      }).filter((t) => !!t).join(",");
      cldAsset.effect(transformationString);
    });
  }
  function constructTransformationString({ effects: effects2, options: options2 }) {
    return Object.keys(effects2).map((key) => {
      const { prefix, qualifier, converters } = effects2[key];
      return constructTransformation({
        qualifier,
        prefix,
        value: options2 == null ? void 0 : options2[key],
        converters
      });
    });
  }
  return {};
}

// src/plugins/flags.ts
var flags_exports = {};
__export(flags_exports, {
  assetTypes: () => assetTypes4,
  plugin: () => plugin4,
  props: () => props4
});
var props4 = ["flags"];
var assetTypes4 = ["image", "images", "video", "videos"];
var supportedFlags = Object.entries(flags).map(([_, { qualifier }]) => qualifier);
function plugin4(props20) {
  const { cldAsset, options } = props20;
  const { flags: flags2 = [] } = options;
  if (Array.isArray(flags2) && flags2.length > 0) {
    flags2.forEach((flag) => {
      if (!supportedFlags.includes(flag))
        return;
      cldAsset.addFlag(flag);
    });
  } else if (typeof flags2 === "object") {
    Object.entries(flags2).forEach(([qualifier, value]) => {
      if (!supportedFlags.includes(qualifier))
        return;
      cldAsset.addTransformation(`fl_${qualifier}:${value}`);
    });
  }
  return {};
}

// src/plugins/fill-background.ts
var fill_background_exports = {};
__export(fill_background_exports, {
  assetTypes: () => assetTypes5,
  plugin: () => plugin5,
  props: () => props5
});
var props5 = ["fillBackground"];
var assetTypes5 = ["image", "images"];
var defaultCrop = "pad";
function plugin5(props20) {
  const { cldAsset, options } = props20;
  const { fillBackground } = options;
  if (fillBackground === true) {
    const properties = [
      "b_gen_fill",
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${defaultCrop}`
    ];
    cldAsset.addTransformation(properties.join(","));
  } else if (typeof fillBackground === "object") {
    const { crop = defaultCrop, gravity, prompt } = fillBackground;
    const properties = [
      `ar_${options.width}:${options.height}`,
      `w_${options.width}`,
      `c_${crop}`
    ];
    if (typeof prompt === "string") {
      properties.unshift(`b_gen_fill:${prompt}`);
    } else {
      properties.unshift(`b_gen_fill`);
    }
    if (typeof gravity === "string") {
      properties.push(`g_${gravity}`);
    }
    cldAsset.addTransformation(properties.join(","));
  }
  return {};
}

// src/plugins/generative-replace.ts
var generative_replace_exports = {};
__export(generative_replace_exports, {
  assetTypes: () => assetTypes6,
  plugin: () => plugin6,
  props: () => props6
});
var props6 = ["replace"];
var assetTypes6 = ["image", "images"];
function plugin6(props20) {
  const { cldAsset, options } = props20;
  const { replace = null } = options;
  if (replace) {
    let from, to, preserveGeometry = false;
    if (Array.isArray(replace)) {
      from = replace[0];
      to = replace[1];
      preserveGeometry = replace[2] || false;
    } else {
      from = replace.from;
      to = replace.to;
      preserveGeometry = replace.preserveGeometry || false;
    }
    const properties = [`e_gen_replace:from_${from}`, `to_${to}`];
    if (preserveGeometry) {
      properties.push(`preserve-geometry_${preserveGeometry}`);
    }
    cldAsset.effect(properties.join(";"));
  }
  return {};
}

// src/plugins/named-transformations.ts
var named_transformations_exports = {};
__export(named_transformations_exports, {
  assetTypes: () => assetTypes7,
  plugin: () => plugin7,
  props: () => props7,
  strict: () => strict
});
var props7 = ["transformations"];
var assetTypes7 = ["image", "images", "video", "videos"];
var strict = true;
function plugin7(props20) {
  const { cldAsset, options } = props20;
  let { transformations = [] } = options;
  if (!Array.isArray(transformations)) {
    transformations = [transformations];
  }
  transformations.forEach((transformation) => {
    cldAsset.addTransformation(`t_${transformation}`);
  });
  return {};
}

// src/plugins/overlays.ts
var overlays_exports = {};
__export(overlays_exports, {
  DEFAULT_TEXT_OPTIONS: () => DEFAULT_TEXT_OPTIONS,
  assetTypes: () => assetTypes8,
  plugin: () => plugin8,
  props: () => props8
});
import { encodeBase64, objectHasKey, sortByKey } from "@cloudinary-util/util";
var props8 = ["text", "overlays"];
var assetTypes8 = ["image", "images", "video", "videos"];
var DEFAULT_TEXT_OPTIONS = {
  color: "black",
  fontFamily: "Arial",
  fontSize: 200,
  fontWeight: "bold"
};
var supportedFlags2 = Object.entries(flags).map(([_, { qualifier }]) => qualifier);
function plugin8(props20) {
  const { cldAsset, options } = props20;
  const { text: text2, overlays = [] } = options;
  const type = "overlay";
  const typeQualifier = "l";
  if (Array.isArray(overlays)) {
    overlays.forEach(applyOverlay);
  }
  if (typeof text2 === "string") {
    applyOverlay({
      text: {
        ...DEFAULT_TEXT_OPTIONS,
        text: text2
      }
    });
  } else if (typeof text2 === "object") {
    applyOverlay({
      text: {
        ...DEFAULT_TEXT_OPTIONS,
        ...text2
      }
    });
  }
  function applyOverlay({ publicId, url, position: position2, text: text3, effects: layerEffects = [], appliedEffects = [], flags: layerFlags = [], appliedFlags = [], ...options2 }) {
    var _a;
    const hasPublicId = typeof publicId === "string";
    const hasUrl = typeof url === "string";
    const hasText = typeof text3 === "object" || typeof text3 === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId && !hasUrl && !hasText) {
      console.warn(`An ${type} is missing Public ID, URL, or Text`);
      return;
    }
    let layerTransformation;
    if (hasText) {
      layerTransformation = `${typeQualifier}_text`;
    } else if (hasPublicId) {
      layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    } else if (hasUrl) {
      layerTransformation = `${typeQualifier}_fetch:${encodeBase64(url)}`;
    }
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey(primary, key))
        return;
      const { qualifier, converters } = primary[key];
      const transformation = constructTransformation({
        qualifier,
        value: options2[key],
        converters
      });
      if (transformation) {
        primary2.push(transformation);
      }
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          primary2.push(transformation);
        }
      });
    });
    appliedEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    });
    layerFlags.forEach((flag) => {
      if (!supportedFlags2.includes(flag))
        return;
      primary2.push(`fl_${flag}`);
    });
    appliedFlags.forEach((flag) => {
      if (!supportedFlags2.includes(flag))
        return;
      applied.push(`fl_${flag}`);
    });
    if (hasText) {
      if (typeof text3 === "string") {
        text3 = {
          ...DEFAULT_TEXT_OPTIONS,
          text: text3
        };
      }
      const textTransformations = [];
      if (typeof text3 === "object") {
        const textOptions = Object.keys(text3).filter((key) => objectHasKey(text, key)).map((key) => {
          const value = text3 && objectHasKey(text3, key) && text3[key];
          return {
            ...text[key],
            key,
            value,
            order: text[key].order || 99
          };
        });
        const sortedTextOptions = sortByKey(textOptions, "order");
        for (const textOption of sortedTextOptions) {
          const { key, value, qualifier, location, converters } = textOption;
          let textValue = value;
          converters == null ? void 0 : converters.forEach(({ test, convert }) => {
            if (!test(value))
              return;
            textValue = convert(value);
          });
          if (location === "primary") {
            primary2.push(`${qualifier}_${textValue}`);
          } else if (qualifier === "self") {
            textTransformations.push(key);
          } else if (qualifier) {
            textTransformations.push(`${qualifier}_${textValue}`);
          } else {
            textTransformations.push(textValue);
          }
        }
      }
      const specialCharacters = {
        ".": "%2E",
        ",": "%2C",
        "/": "%2F"
      };
      let layerText = (text3 == null ? void 0 : text3.text) || "";
      if (typeof layerText === "string") {
        (_a = Object.keys(specialCharacters)) == null ? void 0 : _a.forEach((character) => {
          layerText = layerText == null ? void 0 : layerText.replace(character, specialCharacters[character]);
        });
      }
      layerTransformation = `${layerTransformation}:${textTransformations.join("_")}:${layerText}`;
    }
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey(position, key))
          return;
        const { qualifier, converters } = position[key];
        const transformation = constructTransformation({
          qualifier,
          value: position2[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    }
    if (primary2.length > 0) {
      layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    }
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/raw-transformations.ts
var raw_transformations_exports = {};
__export(raw_transformations_exports, {
  assetTypes: () => assetTypes9,
  plugin: () => plugin9,
  props: () => props9
});
var props9 = ["rawTransformations"];
var assetTypes9 = ["image", "images", "video", "videos"];
function plugin9(props20) {
  const { cldAsset, options } = props20;
  const { rawTransformations = [] } = options;
  rawTransformations.forEach((transformation) => {
    cldAsset.addTransformation(transformation);
  });
  return {};
}

// src/plugins/recolor.ts
var recolor_exports = {};
__export(recolor_exports, {
  assetTypes: () => assetTypes10,
  plugin: () => plugin10,
  props: () => props10
});
var props10 = ["recolor"];
var assetTypes10 = ["image", "images"];
function plugin10(props20) {
  const { cldAsset, options } = props20;
  const { recolor } = options;
  const recolorOptions = {
    prompt: void 0,
    "to-color": void 0,
    multiple: void 0
  };
  if (Array.isArray(recolor)) {
    if (Array.isArray(recolor[0])) {
      recolorOptions.prompt = promptArrayToString(recolor[0]);
    } else {
      recolorOptions.prompt = recolor[0];
    }
    if (typeof recolor[1] === "string") {
      recolorOptions["to-color"] = recolor[1];
    }
  } else if (typeof recolor === "object") {
    if (typeof recolor.prompt === "string") {
      recolorOptions.prompt = recolor.prompt;
    } else if (Array.isArray(recolor.prompt)) {
      recolorOptions.prompt = promptArrayToString(recolor.prompt);
    }
    if (typeof recolor.to === "string") {
      recolorOptions["to-color"] = recolor.to;
    }
    if (recolor.multiple === true) {
      recolorOptions.multiple = `true`;
    }
  }
  const transformation = Object.entries(recolorOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_recolor:${transformation}`);
  }
  return {};
}

// src/plugins/remove.ts
var remove_exports = {};
__export(remove_exports, {
  assetTypes: () => assetTypes11,
  plugin: () => plugin11,
  props: () => props11
});
var props11 = ["remove"];
var assetTypes11 = ["image", "images"];
function plugin11(props20) {
  const { cldAsset, options } = props20;
  const { remove } = options;
  const removeOptions = {
    prompt: void 0,
    region: void 0,
    multiple: void 0,
    "remove-shadow": void 0
  };
  if (typeof remove === "string") {
    removeOptions.prompt = remove;
  } else if (Array.isArray(remove)) {
    removeOptions.prompt = promptArrayToString(remove);
  } else if (typeof remove === "object") {
    const hasPrompt = typeof remove.prompt === "string" || Array.isArray(remove.prompt);
    const hasRegion = Array.isArray(remove.region);
    if (hasPrompt && hasRegion) {
      throw new Error("Invalid remove options: you can not have both a prompt and a region. More info: https://cloudinary.com/documentation/transformation_reference#e_gen_remove");
    }
    if (typeof remove.prompt === "string") {
      removeOptions.prompt = remove.prompt;
    } else if (Array.isArray(remove.prompt)) {
      removeOptions.prompt = promptArrayToString(remove.prompt);
    }
    if (Array.isArray(remove.region)) {
      removeOptions.region = regionArrayToString(remove.region);
    }
    if (remove.multiple === true) {
      removeOptions.multiple = `true`;
    }
    if (remove.removeShadow === true) {
      removeOptions["remove-shadow"] = `true`;
    }
  }
  const transformation = Object.entries(removeOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_remove:${transformation}`);
  }
  return {};
}
function regionArrayToString(regionArray) {
  const indexes = {
    0: "x",
    1: "y",
    2: "w",
    3: "h"
  };
  const regionString = regionArray.map((region, index) => {
    if (Array.isArray(region)) {
      return regionArrayToString(region);
    }
    const key = indexes[index];
    return `${key}_${region}`;
  }).join(";");
  return `(${regionString})`;
}

// src/plugins/remove-background.ts
var remove_background_exports = {};
__export(remove_background_exports, {
  assetTypes: () => assetTypes12,
  plugin: () => plugin12,
  props: () => props12
});
var props12 = ["removeBackground"];
var assetTypes12 = ["image", "images"];
function plugin12(props20) {
  const { cldAsset, options } = props20;
  const { removeBackground = false } = options;
  if (removeBackground) {
    cldAsset.effect("e_background_removal");
  }
  return {};
}

// src/plugins/restore.ts
var restore_exports = {};
__export(restore_exports, {
  assetTypes: () => assetTypes13,
  plugin: () => plugin13,
  props: () => props13
});
var props13 = ["restore"];
var assetTypes13 = ["image", "images"];
function plugin13(props20) {
  const { cldAsset, options } = props20;
  const { restore = false } = options;
  if (restore) {
    cldAsset.effect("e_gen_restore");
  }
  return {};
}

// src/plugins/sanitize.ts
var sanitize_exports = {};
__export(sanitize_exports, {
  assetTypes: () => assetTypes14,
  plugin: () => plugin14,
  props: () => props14
});
var props14 = ["sanitize"];
var assetTypes14 = ["image", "images"];
function plugin14(props20) {
  const { cldAsset, options } = props20;
  const { sanitize = true } = options;
  const shouldApplySanitizer = sanitize && (options.format === "svg" || cldAsset.publicID.endsWith(".svg"));
  if (shouldApplySanitizer) {
    cldAsset.effect("fl_sanitize");
  }
  return {};
}

// src/plugins/seo.ts
var seo_exports = {};
__export(seo_exports, {
  assetTypes: () => assetTypes15,
  plugin: () => plugin15,
  props: () => props15
});
var props15 = ["seoSuffix"];
var assetTypes15 = ["image", "images", "video", "videos"];
function plugin15(props20) {
  const { cldAsset, options } = props20;
  const { seoSuffix } = options;
  if (typeof seoSuffix === "string") {
    if (options.deliveryType === "fetch") {
      console.warn("SEO suffix is not supported with a delivery type of fetch");
    } else {
      cldAsset.setSuffix(seoSuffix);
    }
  }
  return {};
}

// src/plugins/underlays.ts
var underlays_exports = {};
__export(underlays_exports, {
  assetTypes: () => assetTypes16,
  plugin: () => plugin16,
  props: () => props16
});
import { objectHasKey as objectHasKey2 } from "@cloudinary-util/util";
var props16 = ["underlay", "underlays"];
var assetTypes16 = ["image", "images", "video", "videos"];
function plugin16(props20) {
  const { cldAsset, options } = props20;
  const { underlay, underlays = [] } = options;
  const typeQualifier = "u";
  if (Array.isArray(underlays)) {
    underlays.forEach(applyUnderlay);
  }
  if (typeof underlay === "string") {
    const underlayOptions = {
      publicId: underlay,
      crop: "fill",
      width: "1.0",
      height: "1.0",
      flags: ["relative"]
    };
    applyUnderlay(underlayOptions);
  }
  function applyUnderlay({ publicId, type, position: position2, effects: layerEffects = [], flags: flags2 = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId) {
      console.warn(`An ${type} is missing a Public ID`);
      return;
    }
    let layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey2(primary, key))
        return;
      const { qualifier } = primary[key];
      primary2.push(`${qualifier}_${options2[key]}`);
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        if (!objectHasKey2(primary, key))
          return;
        const { qualifier } = primary[key];
        primary2.push(`${qualifier}_${effect[key]}`);
      });
    });
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey2(position, key))
          return;
        const { qualifier } = position[key];
        applied.push(`${qualifier}_${position2[key]}`);
      });
    }
    flags2.forEach((key) => {
      if (!objectHasKey2(flags, key))
        return;
      const { qualifier, prefix } = flags[key];
      primary2.push(`${prefix}_${qualifier}`);
    });
    layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/version.ts
var version_exports = {};
__export(version_exports, {
  assetTypes: () => assetTypes17,
  plugin: () => plugin17,
  props: () => props17
});
var props17 = ["version"];
var assetTypes17 = ["image", "images", "video", "videos"];
function plugin17(props20) {
  const { cldAsset, options } = props20;
  const { version } = options;
  if (typeof version === "string" || typeof version === "number") {
    cldAsset.setVersion(`${version}`.replace("v", ""));
  }
  return {};
}

// src/plugins/video.ts
var video_exports = {};
__export(video_exports, {
  assetTypes: () => assetTypes18,
  plugin: () => plugin18,
  props: () => props18
});
import { objectHasKey as objectHasKey3 } from "@cloudinary-util/util";
var props18 = [...Object.keys(video)];
var assetTypes18 = ["video", "videos"];
function plugin18(props20) {
  const { cldAsset, options } = props20;
  Object.keys(options).forEach((key) => {
    if (!objectHasKey3(video, key))
      return;
    const { prefix, qualifier, converters } = video[key];
    const transformation = constructTransformation({
      prefix,
      qualifier,
      value: options[key],
      converters
    });
    cldAsset.addTransformation(transformation);
  });
  return {};
}

// src/plugins/zoompan.ts
var zoompan_exports = {};
__export(zoompan_exports, {
  assetTypes: () => assetTypes19,
  plugin: () => plugin19,
  props: () => props19
});
var props19 = ["zoompan"];
var assetTypes19 = ["image", "images"];
function plugin19(props20) {
  const { cldAsset, options } = props20;
  const { zoompan = false } = options;
  const overrides = {
    format: void 0
  };
  if (zoompan === true) {
    cldAsset.effect("e_zoompan");
  } else if (typeof zoompan === "string") {
    if (zoompan === "loop") {
      cldAsset.effect("e_zoompan");
      cldAsset.effect("e_loop");
    } else {
      cldAsset.effect(`e_zoompan:${zoompan}`);
    }
  } else if (typeof zoompan === "object") {
    let zoompanEffect = "e_zoompan";
    if (typeof zoompan.options === "string") {
      zoompanEffect = `${zoompanEffect}${zoompan.options}`;
    }
    cldAsset.effect(zoompanEffect);
    let loopEffect;
    if (zoompan.loop === true) {
      loopEffect = "e_loop";
    } else if (typeof zoompan.loop === "string") {
      loopEffect = `e_loop${zoompan.loop}`;
    }
    if (loopEffect) {
      cldAsset.effect(loopEffect);
    }
  }
  if (zoompan !== false) {
    overrides.format = "gif";
  }
  return {
    options: overrides
  };
}

// src/lib/cloudinary.ts
var transformationPlugins = [
  generative_replace_exports,
  recolor_exports,
  remove_exports,
  remove_background_exports,
  restore_exports,
  raw_transformations_exports,
  cropping_exports,
  default_image_exports,
  effects_exports,
  fill_background_exports,
  flags_exports,
  overlays_exports,
  sanitize_exports,
  named_transformations_exports,
  seo_exports,
  underlays_exports,
  version_exports,
  video_exports,
  zoompan_exports
];
function constructCloudinaryUrl({ options, config = {}, analytics }) {
  if (analytics === false) {
    if (typeof (config == null ? void 0 : config.url) === "undefined") {
      config.url = {};
    }
    config.url.analytics = false;
  }
  const cld = new Cloudinary(config);
  if (typeof (options == null ? void 0 : options.src) !== "string") {
    throw Error(`Failed to construct Cloudinary URL: Missing source (src) in options`);
  }
  if (!(options == null ? void 0 : options.assetType)) {
    options.assetType = "image";
  }
  const propsCheck = [];
  transformationPlugins.forEach(({ props: props20 = [] }) => {
    props20.forEach((prop) => {
      if (propsCheck.includes(prop)) {
        throw new Error(`Option ${prop} already exists!`);
      }
      propsCheck.push(prop);
    });
  });
  const parsedOptions = {};
  let publicId;
  if (typeof options.src === "string" && /^https?:\/\//.test(options.src)) {
    try {
      const parts = parseUrl(options.src);
      publicId = parts == null ? void 0 : parts.publicId;
      parsedOptions.seoSuffix = parts == null ? void 0 : parts.seoSuffix;
      parsedOptions.version = parts == null ? void 0 : parts.version;
    } catch (e) {
    }
  }
  if (!publicId) {
    publicId = options.src;
  }
  Object.keys(parsedOptions).forEach((key) => {
    if (objectHasKey4(options, key))
      return;
    options[key] = parsedOptions[key];
  });
  let cldAsset = void 0;
  if (["image", "images"].includes(options.assetType)) {
    cldAsset = cld.image(publicId);
  } else if (["video", "videos"].includes(options.assetType)) {
    cldAsset = cld.video(publicId);
  }
  if (typeof cldAsset === "undefined") {
    throw new Error("Invalid asset type.");
  }
  transformationPlugins.forEach(({ plugin: plugin20, assetTypes: assetTypes20, props: props20, strict: strict2 }) => {
    const supportedAssetType = typeof (options == null ? void 0 : options.assetType) !== "undefined" && assetTypes20.includes(options == null ? void 0 : options.assetType);
    const optionsKeys = Object.keys(options);
    const attemptedUse = props20.map((prop) => optionsKeys.includes(prop)).filter((isUsed) => !!isUsed).length > 0;
    if (!supportedAssetType) {
      if (attemptedUse) {
        console.warn(`One of the following props [${props20.join(", ")}] was used with an unsupported asset type [${options == null ? void 0 : options.assetType}]`);
      }
      return;
    }
    if (options.strictTransformations && !strict2) {
      if (attemptedUse) {
        console.warn(`One of the following props [${props20.join(", ")}] was used that is not supported with Strict Transformations.`);
      }
      return;
    }
    const results = plugin20({
      cldAsset,
      options
    });
    const { options: pluginOptions } = results || { options: void 0 };
    if ((pluginOptions == null ? void 0 : pluginOptions.format) && options) {
      options.format = pluginOptions.format;
    }
    if ((pluginOptions == null ? void 0 : pluginOptions.width) && options) {
      options.resize = {
        width: pluginOptions == null ? void 0 : pluginOptions.width
      };
    }
  });
  if ((options == null ? void 0 : options.resize) && !options.strictTransformations) {
    const { width, crop = "limit" } = options.resize;
    cldAsset.effect(`c_${crop},w_${width}`);
  }
  cldAsset.setDeliveryType((options == null ? void 0 : options.deliveryType) || "upload");
  if (!options.strictTransformations) {
    if (options == null ? void 0 : options.dpr) {
      let dpr = options.dpr;
      if (typeof dpr === "number") {
        dpr = dpr.toFixed(1);
      }
      cldAsset.addTransformation(`dpr_${dpr}`);
    }
    if ((options == null ? void 0 : options.format) !== "default") {
      cldAsset.format((options == null ? void 0 : options.format) || "auto");
    }
    if ((options == null ? void 0 : options.quality) !== "default") {
      cldAsset.quality((options == null ? void 0 : options.quality) || "auto");
    }
  }
  return cldAsset.toURL({
    trackedAnalytics: analytics
  });
}
export {
  constructCloudinaryUrl,
  effects,
  position,
  primary,
  text,
  transformationPlugins
};
